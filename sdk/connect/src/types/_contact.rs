// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Contains information about a contact.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The identifier for the contact.</p>
    pub id: ::std::option::Option<::std::string::String>,
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub initial_contact_id: ::std::option::Option<::std::string::String>,
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub previous_contact_id: ::std::option::Option<::std::string::String>,
    /// <p>Indicates how the contact was initiated.</p>
    pub initiation_method: ::std::option::Option<crate::types::ContactInitiationMethod>,
    /// <p>The name of the contact.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The description of the contact.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>How the contact reached your contact center.</p>
    pub channel: ::std::option::Option<crate::types::Channel>,
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub queue_info: ::std::option::Option<crate::types::QueueInfo>,
    /// <p>Information about the agent who accepted the contact.</p>
    pub agent_info: ::std::option::Option<crate::types::AgentInfo>,
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub initiation_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub disconnect_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when contact was last updated.</p>
    pub last_update_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when the contact was last paused.</p>
    pub last_paused_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The timestamp when the contact was last resumed.</p>
    pub last_resumed_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Total pause count for a contact.</p>
    pub total_pause_count: ::std::option::Option<i32>,
    /// <p>Total pause duration for a contact in seconds.</p>
    pub total_pause_duration_in_seconds: ::std::option::Option<i32>,
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub scheduled_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub related_contact_id: ::std::option::Option<::std::string::String>,
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub wisdom_info: ::std::option::Option<crate::types::WisdomInfo>,
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub queue_time_adjustment_seconds: ::std::option::Option<i32>,
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub queue_priority: ::std::option::Option<i64>,
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl Contact {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn arn(&self) -> ::std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The identifier for the contact.</p>
    pub fn id(&self) -> ::std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn initial_contact_id(&self) -> ::std::option::Option<&str> {
        self.initial_contact_id.as_deref()
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn previous_contact_id(&self) -> ::std::option::Option<&str> {
        self.previous_contact_id.as_deref()
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn initiation_method(&self) -> ::std::option::Option<&crate::types::ContactInitiationMethod> {
        self.initiation_method.as_ref()
    }
    /// <p>The name of the contact.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the contact.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn channel(&self) -> ::std::option::Option<&crate::types::Channel> {
        self.channel.as_ref()
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn queue_info(&self) -> ::std::option::Option<&crate::types::QueueInfo> {
        self.queue_info.as_ref()
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn agent_info(&self) -> ::std::option::Option<&crate::types::AgentInfo> {
        self.agent_info.as_ref()
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn initiation_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.initiation_timestamp.as_ref()
    }
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub fn disconnect_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.disconnect_timestamp.as_ref()
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn last_update_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_update_timestamp.as_ref()
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn last_paused_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_paused_timestamp.as_ref()
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn last_resumed_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_resumed_timestamp.as_ref()
    }
    /// <p>Total pause count for a contact.</p>
    pub fn total_pause_count(&self) -> ::std::option::Option<i32> {
        self.total_pause_count
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn total_pause_duration_in_seconds(&self) -> ::std::option::Option<i32> {
        self.total_pause_duration_in_seconds
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn scheduled_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.scheduled_timestamp.as_ref()
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn related_contact_id(&self) -> ::std::option::Option<&str> {
        self.related_contact_id.as_deref()
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn wisdom_info(&self) -> ::std::option::Option<&crate::types::WisdomInfo> {
        self.wisdom_info.as_ref()
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn queue_time_adjustment_seconds(&self) -> ::std::option::Option<i32> {
        self.queue_time_adjustment_seconds
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn queue_priority(&self) -> ::std::option::Option<i64> {
        self.queue_priority
    }
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl ::std::fmt::Debug for Contact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("Contact");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("initial_contact_id", &self.initial_contact_id);
        formatter.field("previous_contact_id", &self.previous_contact_id);
        formatter.field("initiation_method", &self.initiation_method);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("channel", &self.channel);
        formatter.field("queue_info", &self.queue_info);
        formatter.field("agent_info", &self.agent_info);
        formatter.field("initiation_timestamp", &self.initiation_timestamp);
        formatter.field("disconnect_timestamp", &self.disconnect_timestamp);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.field("last_paused_timestamp", &self.last_paused_timestamp);
        formatter.field("last_resumed_timestamp", &self.last_resumed_timestamp);
        formatter.field("total_pause_count", &self.total_pause_count);
        formatter.field("total_pause_duration_in_seconds", &self.total_pause_duration_in_seconds);
        formatter.field("scheduled_timestamp", &self.scheduled_timestamp);
        formatter.field("related_contact_id", &self.related_contact_id);
        formatter.field("wisdom_info", &self.wisdom_info);
        formatter.field("queue_time_adjustment_seconds", &self.queue_time_adjustment_seconds);
        formatter.field("queue_priority", &self.queue_priority);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
impl Contact {
    /// Creates a new builder-style object to manufacture [`Contact`](crate::types::Contact).
    pub fn builder() -> crate::types::builders::ContactBuilder {
        crate::types::builders::ContactBuilder::default()
    }
}

/// A builder for [`Contact`](crate::types::Contact).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct ContactBuilder {
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) initial_contact_id: ::std::option::Option<::std::string::String>,
    pub(crate) previous_contact_id: ::std::option::Option<::std::string::String>,
    pub(crate) initiation_method: ::std::option::Option<crate::types::ContactInitiationMethod>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) channel: ::std::option::Option<crate::types::Channel>,
    pub(crate) queue_info: ::std::option::Option<crate::types::QueueInfo>,
    pub(crate) agent_info: ::std::option::Option<crate::types::AgentInfo>,
    pub(crate) initiation_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) disconnect_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_update_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_paused_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_resumed_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) total_pause_count: ::std::option::Option<i32>,
    pub(crate) total_pause_duration_in_seconds: ::std::option::Option<i32>,
    pub(crate) scheduled_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) related_contact_id: ::std::option::Option<::std::string::String>,
    pub(crate) wisdom_info: ::std::option::Option<crate::types::WisdomInfo>,
    pub(crate) queue_time_adjustment_seconds: ::std::option::Option<i32>,
    pub(crate) queue_priority: ::std::option::Option<i64>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl ContactBuilder {
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) for the contact.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The identifier for the contact.</p>
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier for the contact.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>The identifier for the contact.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn initial_contact_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.initial_contact_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn set_initial_contact_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.initial_contact_id = input;
        self
    }
    /// <p>If this contact is related to other contacts, this is the ID of the initial contact.</p>
    pub fn get_initial_contact_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.initial_contact_id
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn previous_contact_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.previous_contact_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn set_previous_contact_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.previous_contact_id = input;
        self
    }
    /// <p>If this contact is not the first contact, this is the ID of the previous contact.</p>
    pub fn get_previous_contact_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.previous_contact_id
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn initiation_method(mut self, input: crate::types::ContactInitiationMethod) -> Self {
        self.initiation_method = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn set_initiation_method(mut self, input: ::std::option::Option<crate::types::ContactInitiationMethod>) -> Self {
        self.initiation_method = input;
        self
    }
    /// <p>Indicates how the contact was initiated.</p>
    pub fn get_initiation_method(&self) -> &::std::option::Option<crate::types::ContactInitiationMethod> {
        &self.initiation_method
    }
    /// <p>The name of the contact.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the contact.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the contact.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The description of the contact.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description of the contact.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description of the contact.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn channel(mut self, input: crate::types::Channel) -> Self {
        self.channel = ::std::option::Option::Some(input);
        self
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn set_channel(mut self, input: ::std::option::Option<crate::types::Channel>) -> Self {
        self.channel = input;
        self
    }
    /// <p>How the contact reached your contact center.</p>
    pub fn get_channel(&self) -> &::std::option::Option<crate::types::Channel> {
        &self.channel
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn queue_info(mut self, input: crate::types::QueueInfo) -> Self {
        self.queue_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn set_queue_info(mut self, input: ::std::option::Option<crate::types::QueueInfo>) -> Self {
        self.queue_info = input;
        self
    }
    /// <p>If this contact was queued, this contains information about the queue.</p>
    pub fn get_queue_info(&self) -> &::std::option::Option<crate::types::QueueInfo> {
        &self.queue_info
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn agent_info(mut self, input: crate::types::AgentInfo) -> Self {
        self.agent_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn set_agent_info(mut self, input: ::std::option::Option<crate::types::AgentInfo>) -> Self {
        self.agent_info = input;
        self
    }
    /// <p>Information about the agent who accepted the contact.</p>
    pub fn get_agent_info(&self) -> &::std::option::Option<crate::types::AgentInfo> {
        &self.agent_info
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn initiation_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.initiation_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn set_initiation_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.initiation_timestamp = input;
        self
    }
    /// <p>The date and time this contact was initiated, in UTC time. For <code>INBOUND</code>, this is when the contact arrived. For <code>OUTBOUND</code>, this is when the agent began dialing. For <code>CALLBACK</code>, this is when the callback contact was created. For <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the transfer was initiated. For <code>API</code>, this is when the request arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the external participant. For <code>MONITOR</code>, this is when the supervisor started listening to a contact.</p>
    pub fn get_initiation_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.initiation_timestamp
    }
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub fn disconnect_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.disconnect_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub fn set_disconnect_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.disconnect_timestamp = input;
        self
    }
    /// <p>The timestamp when the customer endpoint disconnected from Amazon Connect.</p>
    pub fn get_disconnect_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.disconnect_timestamp
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn last_update_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_update_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn set_last_update_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_update_timestamp = input;
        self
    }
    /// <p>The timestamp when contact was last updated.</p>
    pub fn get_last_update_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_update_timestamp
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn last_paused_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_paused_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn set_last_paused_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_paused_timestamp = input;
        self
    }
    /// <p>The timestamp when the contact was last paused.</p>
    pub fn get_last_paused_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_paused_timestamp
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn last_resumed_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_resumed_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn set_last_resumed_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_resumed_timestamp = input;
        self
    }
    /// <p>The timestamp when the contact was last resumed.</p>
    pub fn get_last_resumed_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_resumed_timestamp
    }
    /// <p>Total pause count for a contact.</p>
    pub fn total_pause_count(mut self, input: i32) -> Self {
        self.total_pause_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>Total pause count for a contact.</p>
    pub fn set_total_pause_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_pause_count = input;
        self
    }
    /// <p>Total pause count for a contact.</p>
    pub fn get_total_pause_count(&self) -> &::std::option::Option<i32> {
        &self.total_pause_count
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn total_pause_duration_in_seconds(mut self, input: i32) -> Self {
        self.total_pause_duration_in_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn set_total_pause_duration_in_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_pause_duration_in_seconds = input;
        self
    }
    /// <p>Total pause duration for a contact in seconds.</p>
    pub fn get_total_pause_duration_in_seconds(&self) -> &::std::option::Option<i32> {
        &self.total_pause_duration_in_seconds
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn scheduled_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.scheduled_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn set_scheduled_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.scheduled_timestamp = input;
        self
    }
    /// <p>The timestamp, in Unix epoch time format, at which to start running the inbound flow.</p>
    pub fn get_scheduled_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.scheduled_timestamp
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn related_contact_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.related_contact_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn set_related_contact_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.related_contact_id = input;
        self
    }
    /// <p>The contactId that is <a href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a> to this contact.</p>
    pub fn get_related_contact_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.related_contact_id
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn wisdom_info(mut self, input: crate::types::WisdomInfo) -> Self {
        self.wisdom_info = ::std::option::Option::Some(input);
        self
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn set_wisdom_info(mut self, input: ::std::option::Option<crate::types::WisdomInfo>) -> Self {
        self.wisdom_info = input;
        self
    }
    /// <p>Information about Amazon Connect Wisdom.</p>
    pub fn get_wisdom_info(&self) -> &::std::option::Option<crate::types::WisdomInfo> {
        &self.wisdom_info
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn queue_time_adjustment_seconds(mut self, input: i32) -> Self {
        self.queue_time_adjustment_seconds = ::std::option::Option::Some(input);
        self
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn set_queue_time_adjustment_seconds(mut self, input: ::std::option::Option<i32>) -> Self {
        self.queue_time_adjustment_seconds = input;
        self
    }
    /// <p>An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.</p>
    pub fn get_queue_time_adjustment_seconds(&self) -> &::std::option::Option<i32> {
        &self.queue_time_adjustment_seconds
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn queue_priority(mut self, input: i64) -> Self {
        self.queue_priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn set_queue_priority(mut self, input: ::std::option::Option<i64>) -> Self {
        self.queue_priority = input;
        self
    }
    /// <p>An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.</p>
    pub fn get_queue_priority(&self) -> &::std::option::Option<i64> {
        &self.queue_priority
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`Contact`](crate::types::Contact).
    pub fn build(self) -> crate::types::Contact {
        crate::types::Contact {
            arn: self.arn,
            id: self.id,
            initial_contact_id: self.initial_contact_id,
            previous_contact_id: self.previous_contact_id,
            initiation_method: self.initiation_method,
            name: self.name,
            description: self.description,
            channel: self.channel,
            queue_info: self.queue_info,
            agent_info: self.agent_info,
            initiation_timestamp: self.initiation_timestamp,
            disconnect_timestamp: self.disconnect_timestamp,
            last_update_timestamp: self.last_update_timestamp,
            last_paused_timestamp: self.last_paused_timestamp,
            last_resumed_timestamp: self.last_resumed_timestamp,
            total_pause_count: self.total_pause_count,
            total_pause_duration_in_seconds: self.total_pause_duration_in_seconds,
            scheduled_timestamp: self.scheduled_timestamp,
            related_contact_id: self.related_contact_id,
            wisdom_info: self.wisdom_info,
            queue_time_adjustment_seconds: self.queue_time_adjustment_seconds,
            queue_priority: self.queue_priority,
            tags: self.tags,
        }
    }
}
impl ::std::fmt::Debug for ContactBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("ContactBuilder");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("initial_contact_id", &self.initial_contact_id);
        formatter.field("previous_contact_id", &self.previous_contact_id);
        formatter.field("initiation_method", &self.initiation_method);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("channel", &self.channel);
        formatter.field("queue_info", &self.queue_info);
        formatter.field("agent_info", &self.agent_info);
        formatter.field("initiation_timestamp", &self.initiation_timestamp);
        formatter.field("disconnect_timestamp", &self.disconnect_timestamp);
        formatter.field("last_update_timestamp", &self.last_update_timestamp);
        formatter.field("last_paused_timestamp", &self.last_paused_timestamp);
        formatter.field("last_resumed_timestamp", &self.last_resumed_timestamp);
        formatter.field("total_pause_count", &self.total_pause_count);
        formatter.field("total_pause_duration_in_seconds", &self.total_pause_duration_in_seconds);
        formatter.field("scheduled_timestamp", &self.scheduled_timestamp);
        formatter.field("related_contact_id", &self.related_contact_id);
        formatter.field("wisdom_info", &self.wisdom_info);
        formatter.field("queue_time_adjustment_seconds", &self.queue_time_adjustment_seconds);
        formatter.field("queue_priority", &self.queue_priority);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
