// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `X12TransactionSet`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let x12transactionset = unimplemented!();
/// match x12transactionset {
///     X12TransactionSet::X12110 => { /* ... */ },
///     X12TransactionSet::X12180 => { /* ... */ },
///     X12TransactionSet::X12204 => { /* ... */ },
///     X12TransactionSet::X12210 => { /* ... */ },
///     X12TransactionSet::X12214 => { /* ... */ },
///     X12TransactionSet::X12215 => { /* ... */ },
///     X12TransactionSet::X12310 => { /* ... */ },
///     X12TransactionSet::X12315 => { /* ... */ },
///     X12TransactionSet::X12322 => { /* ... */ },
///     X12TransactionSet::X12404 => { /* ... */ },
///     X12TransactionSet::X12410 => { /* ... */ },
///     X12TransactionSet::X12820 => { /* ... */ },
///     X12TransactionSet::X12824 => { /* ... */ },
///     X12TransactionSet::X12830 => { /* ... */ },
///     X12TransactionSet::X12846 => { /* ... */ },
///     X12TransactionSet::X12850 => { /* ... */ },
///     X12TransactionSet::X12852 => { /* ... */ },
///     X12TransactionSet::X12855 => { /* ... */ },
///     X12TransactionSet::X12856 => { /* ... */ },
///     X12TransactionSet::X12860 => { /* ... */ },
///     X12TransactionSet::X12861 => { /* ... */ },
///     X12TransactionSet::X12864 => { /* ... */ },
///     X12TransactionSet::X12940 => { /* ... */ },
///     X12TransactionSet::X12990 => { /* ... */ },
///     X12TransactionSet::X12997 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `x12transactionset` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `X12TransactionSet::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `X12TransactionSet::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `X12TransactionSet::NewFeature` is defined.
/// Specifically, when `x12transactionset` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `X12TransactionSet::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub enum X12TransactionSet {
    #[allow(missing_docs)] // documentation missing in model
    X12110,
    #[allow(missing_docs)] // documentation missing in model
    X12180,
    #[allow(missing_docs)] // documentation missing in model
    X12204,
    #[allow(missing_docs)] // documentation missing in model
    X12210,
    #[allow(missing_docs)] // documentation missing in model
    X12214,
    #[allow(missing_docs)] // documentation missing in model
    X12215,
    #[allow(missing_docs)] // documentation missing in model
    X12310,
    #[allow(missing_docs)] // documentation missing in model
    X12315,
    #[allow(missing_docs)] // documentation missing in model
    X12322,
    #[allow(missing_docs)] // documentation missing in model
    X12404,
    #[allow(missing_docs)] // documentation missing in model
    X12410,
    #[allow(missing_docs)] // documentation missing in model
    X12820,
    #[allow(missing_docs)] // documentation missing in model
    X12824,
    #[allow(missing_docs)] // documentation missing in model
    X12830,
    #[allow(missing_docs)] // documentation missing in model
    X12846,
    #[allow(missing_docs)] // documentation missing in model
    X12850,
    #[allow(missing_docs)] // documentation missing in model
    X12852,
    #[allow(missing_docs)] // documentation missing in model
    X12855,
    #[allow(missing_docs)] // documentation missing in model
    X12856,
    #[allow(missing_docs)] // documentation missing in model
    X12860,
    #[allow(missing_docs)] // documentation missing in model
    X12861,
    #[allow(missing_docs)] // documentation missing in model
    X12864,
    #[allow(missing_docs)] // documentation missing in model
    X12940,
    #[allow(missing_docs)] // documentation missing in model
    X12990,
    #[allow(missing_docs)] // documentation missing in model
    X12997,
    /// `Unknown` contains new variants that have been added since this code was generated.
    #[deprecated(note = "Don't directly match on `Unknown`. See the docs on this enum for the correct way to handle unknown variants.")]
    Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue),
}
impl ::std::convert::From<&str> for X12TransactionSet {
    fn from(s: &str) -> Self {
        match s {
            "X12_110" => X12TransactionSet::X12110,
            "X12_180" => X12TransactionSet::X12180,
            "X12_204" => X12TransactionSet::X12204,
            "X12_210" => X12TransactionSet::X12210,
            "X12_214" => X12TransactionSet::X12214,
            "X12_215" => X12TransactionSet::X12215,
            "X12_310" => X12TransactionSet::X12310,
            "X12_315" => X12TransactionSet::X12315,
            "X12_322" => X12TransactionSet::X12322,
            "X12_404" => X12TransactionSet::X12404,
            "X12_410" => X12TransactionSet::X12410,
            "X12_820" => X12TransactionSet::X12820,
            "X12_824" => X12TransactionSet::X12824,
            "X12_830" => X12TransactionSet::X12830,
            "X12_846" => X12TransactionSet::X12846,
            "X12_850" => X12TransactionSet::X12850,
            "X12_852" => X12TransactionSet::X12852,
            "X12_855" => X12TransactionSet::X12855,
            "X12_856" => X12TransactionSet::X12856,
            "X12_860" => X12TransactionSet::X12860,
            "X12_861" => X12TransactionSet::X12861,
            "X12_864" => X12TransactionSet::X12864,
            "X12_940" => X12TransactionSet::X12940,
            "X12_990" => X12TransactionSet::X12990,
            "X12_997" => X12TransactionSet::X12997,
            other => X12TransactionSet::Unknown(crate::primitives::sealed_enum_unknown::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl ::std::str::FromStr for X12TransactionSet {
    type Err = ::std::convert::Infallible;

    fn from_str(s: &str) -> ::std::result::Result<Self, <Self as ::std::str::FromStr>::Err> {
        ::std::result::Result::Ok(X12TransactionSet::from(s))
    }
}
impl X12TransactionSet {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            X12TransactionSet::X12110 => "X12_110",
            X12TransactionSet::X12180 => "X12_180",
            X12TransactionSet::X12204 => "X12_204",
            X12TransactionSet::X12210 => "X12_210",
            X12TransactionSet::X12214 => "X12_214",
            X12TransactionSet::X12215 => "X12_215",
            X12TransactionSet::X12310 => "X12_310",
            X12TransactionSet::X12315 => "X12_315",
            X12TransactionSet::X12322 => "X12_322",
            X12TransactionSet::X12404 => "X12_404",
            X12TransactionSet::X12410 => "X12_410",
            X12TransactionSet::X12820 => "X12_820",
            X12TransactionSet::X12824 => "X12_824",
            X12TransactionSet::X12830 => "X12_830",
            X12TransactionSet::X12846 => "X12_846",
            X12TransactionSet::X12850 => "X12_850",
            X12TransactionSet::X12852 => "X12_852",
            X12TransactionSet::X12855 => "X12_855",
            X12TransactionSet::X12856 => "X12_856",
            X12TransactionSet::X12860 => "X12_860",
            X12TransactionSet::X12861 => "X12_861",
            X12TransactionSet::X12864 => "X12_864",
            X12TransactionSet::X12940 => "X12_940",
            X12TransactionSet::X12990 => "X12_990",
            X12TransactionSet::X12997 => "X12_997",
            X12TransactionSet::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "X12_110", "X12_180", "X12_204", "X12_210", "X12_214", "X12_215", "X12_310", "X12_315", "X12_322", "X12_404", "X12_410", "X12_820",
            "X12_824", "X12_830", "X12_846", "X12_850", "X12_852", "X12_855", "X12_856", "X12_860", "X12_861", "X12_864", "X12_940", "X12_990",
            "X12_997",
        ]
    }
}
impl ::std::convert::AsRef<str> for X12TransactionSet {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl X12TransactionSet {
    /// Parses the enum value while disallowing unknown variants.
    ///
    /// Unknown variants will result in an error.
    pub fn try_parse(value: &str) -> ::std::result::Result<Self, crate::error::UnknownVariantError> {
        match Self::from(value) {
            #[allow(deprecated)]
            Self::Unknown(_) => ::std::result::Result::Err(crate::error::UnknownVariantError::new(value)),
            known => Ok(known),
        }
    }
}
