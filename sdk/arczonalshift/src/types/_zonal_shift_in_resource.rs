// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A complex structure that lists the zonal shifts for a managed resource and their statuses for the resource.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ZonalShiftInResource {
    /// <p>The <code>appliedStatus</code> field specifies which application traffic shift is in effect for a resource when there is more than one traffic shift active. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-started zonal shifts, or an autoshift. The <code>appliedStatus</code> field for an autoshift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. The zonal shift or autoshift that is currently in effect for the resource has an applied status set to <code>APPLIED</code>.</p>
    /// <p>The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-started zonal shifts &gt; autoshifts &gt; practice run zonal shifts.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html">How zonal autoshift and practice runs work</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub applied_status: crate::types::AppliedStatus,
    /// <p>The identifier of a zonal shift.</p>
    pub zonal_shift_id: ::std::string::String,
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    pub resource_identifier: ::std::string::String,
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.</p>
    pub away_from: ::std::string::String,
    /// <p>The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time.</p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.</p>
    pub expiry_time: ::aws_smithy_types::DateTime,
    /// <p>The time (UTC) when the zonal shift starts.</p>
    pub start_time: ::aws_smithy_types::DateTime,
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    pub comment: ::std::string::String,
    /// <p>The outcome, or end state, returned for a practice run. The following values can be returned:</p>
    /// <ul>
    /// <li>
    /// <p><b>PENDING:</b> Outcome value when a practice run is in progress.</p></li>
    /// <li>
    /// <p><b>SUCCEEDED:</b> Outcome value when the outcome alarm specified for the practice run configuration does not go into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed the expected 30 minute zonal shift.</p></li>
    /// <li>
    /// <p><b>INTERRUPTED:</b> Outcome value when the practice run was stopped before the expected 30 minute zonal shift duration, or there was another problem with the practice run that created an inconclusive outcome.</p></li>
    /// <li>
    /// <p><b>FAILED:</b> Outcome value when the outcome alarm specified for the practice run configuration goes into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed.</p></li>
    /// </ul>
    /// <p>For more information about practice run outcomes, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html"> Considerations when you configure zonal autoshift</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub practice_run_outcome: ::std::option::Option<crate::types::PracticeRunOutcome>,
}
impl ZonalShiftInResource {
    /// <p>The <code>appliedStatus</code> field specifies which application traffic shift is in effect for a resource when there is more than one traffic shift active. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-started zonal shifts, or an autoshift. The <code>appliedStatus</code> field for an autoshift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. The zonal shift or autoshift that is currently in effect for the resource has an applied status set to <code>APPLIED</code>.</p>
    /// <p>The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-started zonal shifts &gt; autoshifts &gt; practice run zonal shifts.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html">How zonal autoshift and practice runs work</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub fn applied_status(&self) -> &crate::types::AppliedStatus {
        &self.applied_status
    }
    /// <p>The identifier of a zonal shift.</p>
    pub fn zonal_shift_id(&self) -> &str {
        use std::ops::Deref;
        self.zonal_shift_id.deref()
    }
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    pub fn resource_identifier(&self) -> &str {
        use std::ops::Deref;
        self.resource_identifier.deref()
    }
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.</p>
    pub fn away_from(&self) -> &str {
        use std::ops::Deref;
        self.away_from.deref()
    }
    /// <p>The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time.</p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.</p>
    pub fn expiry_time(&self) -> &::aws_smithy_types::DateTime {
        &self.expiry_time
    }
    /// <p>The time (UTC) when the zonal shift starts.</p>
    pub fn start_time(&self) -> &::aws_smithy_types::DateTime {
        &self.start_time
    }
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    pub fn comment(&self) -> &str {
        use std::ops::Deref;
        self.comment.deref()
    }
    /// <p>The outcome, or end state, returned for a practice run. The following values can be returned:</p>
    /// <ul>
    /// <li>
    /// <p><b>PENDING:</b> Outcome value when a practice run is in progress.</p></li>
    /// <li>
    /// <p><b>SUCCEEDED:</b> Outcome value when the outcome alarm specified for the practice run configuration does not go into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed the expected 30 minute zonal shift.</p></li>
    /// <li>
    /// <p><b>INTERRUPTED:</b> Outcome value when the practice run was stopped before the expected 30 minute zonal shift duration, or there was another problem with the practice run that created an inconclusive outcome.</p></li>
    /// <li>
    /// <p><b>FAILED:</b> Outcome value when the outcome alarm specified for the practice run configuration goes into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed.</p></li>
    /// </ul>
    /// <p>For more information about practice run outcomes, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html"> Considerations when you configure zonal autoshift</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub fn practice_run_outcome(&self) -> ::std::option::Option<&crate::types::PracticeRunOutcome> {
        self.practice_run_outcome.as_ref()
    }
}
impl ZonalShiftInResource {
    /// Creates a new builder-style object to manufacture [`ZonalShiftInResource`](crate::types::ZonalShiftInResource).
    pub fn builder() -> crate::types::builders::ZonalShiftInResourceBuilder {
        crate::types::builders::ZonalShiftInResourceBuilder::default()
    }
}

/// A builder for [`ZonalShiftInResource`](crate::types::ZonalShiftInResource).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ZonalShiftInResourceBuilder {
    pub(crate) applied_status: ::std::option::Option<crate::types::AppliedStatus>,
    pub(crate) zonal_shift_id: ::std::option::Option<::std::string::String>,
    pub(crate) resource_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) away_from: ::std::option::Option<::std::string::String>,
    pub(crate) expiry_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) start_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) comment: ::std::option::Option<::std::string::String>,
    pub(crate) practice_run_outcome: ::std::option::Option<crate::types::PracticeRunOutcome>,
}
impl ZonalShiftInResourceBuilder {
    /// <p>The <code>appliedStatus</code> field specifies which application traffic shift is in effect for a resource when there is more than one traffic shift active. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-started zonal shifts, or an autoshift. The <code>appliedStatus</code> field for an autoshift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. The zonal shift or autoshift that is currently in effect for the resource has an applied status set to <code>APPLIED</code>.</p>
    /// <p>The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-started zonal shifts &gt; autoshifts &gt; practice run zonal shifts.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html">How zonal autoshift and practice runs work</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    /// This field is required.
    pub fn applied_status(mut self, input: crate::types::AppliedStatus) -> Self {
        self.applied_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The <code>appliedStatus</code> field specifies which application traffic shift is in effect for a resource when there is more than one traffic shift active. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-started zonal shifts, or an autoshift. The <code>appliedStatus</code> field for an autoshift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. The zonal shift or autoshift that is currently in effect for the resource has an applied status set to <code>APPLIED</code>.</p>
    /// <p>The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-started zonal shifts &gt; autoshifts &gt; practice run zonal shifts.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html">How zonal autoshift and practice runs work</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub fn set_applied_status(mut self, input: ::std::option::Option<crate::types::AppliedStatus>) -> Self {
        self.applied_status = input;
        self
    }
    /// <p>The <code>appliedStatus</code> field specifies which application traffic shift is in effect for a resource when there is more than one traffic shift active. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-started zonal shifts, or an autoshift. The <code>appliedStatus</code> field for an autoshift for a resource can have one of two values: <code>APPLIED</code> or <code>NOT_APPLIED</code>. The zonal shift or autoshift that is currently in effect for the resource has an applied status set to <code>APPLIED</code>.</p>
    /// <p>The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-started zonal shifts &gt; autoshifts &gt; practice run zonal shifts.</p>
    /// <p>For more information, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html">How zonal autoshift and practice runs work</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub fn get_applied_status(&self) -> &::std::option::Option<crate::types::AppliedStatus> {
        &self.applied_status
    }
    /// <p>The identifier of a zonal shift.</p>
    /// This field is required.
    pub fn zonal_shift_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.zonal_shift_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of a zonal shift.</p>
    pub fn set_zonal_shift_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.zonal_shift_id = input;
        self
    }
    /// <p>The identifier of a zonal shift.</p>
    pub fn get_zonal_shift_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.zonal_shift_id
    }
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    /// This field is required.
    pub fn resource_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.resource_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    pub fn set_resource_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.resource_identifier = input;
        self
    }
    /// <p>The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource.</p>
    /// <p>At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.</p>
    pub fn get_resource_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.resource_identifier
    }
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.</p>
    /// This field is required.
    pub fn away_from(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.away_from = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.</p>
    pub fn set_away_from(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.away_from = input;
        self
    }
    /// <p>The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.</p>
    pub fn get_away_from(&self) -> &::std::option::Option<::std::string::String> {
        &self.away_from
    }
    /// <p>The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time.</p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.</p>
    /// This field is required.
    pub fn expiry_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.expiry_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time.</p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.</p>
    pub fn set_expiry_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.expiry_time = input;
        self
    }
    /// <p>The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time.</p>
    /// <p>When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.</p>
    pub fn get_expiry_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.expiry_time
    }
    /// <p>The time (UTC) when the zonal shift starts.</p>
    /// This field is required.
    pub fn start_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.start_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time (UTC) when the zonal shift starts.</p>
    pub fn set_start_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.start_time = input;
        self
    }
    /// <p>The time (UTC) when the zonal shift starts.</p>
    pub fn get_start_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.start_time
    }
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    /// This field is required.
    pub fn comment(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.comment = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    pub fn set_comment(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.comment = input;
        self
    }
    /// <p>A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.</p>
    pub fn get_comment(&self) -> &::std::option::Option<::std::string::String> {
        &self.comment
    }
    /// <p>The outcome, or end state, returned for a practice run. The following values can be returned:</p>
    /// <ul>
    /// <li>
    /// <p><b>PENDING:</b> Outcome value when a practice run is in progress.</p></li>
    /// <li>
    /// <p><b>SUCCEEDED:</b> Outcome value when the outcome alarm specified for the practice run configuration does not go into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed the expected 30 minute zonal shift.</p></li>
    /// <li>
    /// <p><b>INTERRUPTED:</b> Outcome value when the practice run was stopped before the expected 30 minute zonal shift duration, or there was another problem with the practice run that created an inconclusive outcome.</p></li>
    /// <li>
    /// <p><b>FAILED:</b> Outcome value when the outcome alarm specified for the practice run configuration goes into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed.</p></li>
    /// </ul>
    /// <p>For more information about practice run outcomes, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html"> Considerations when you configure zonal autoshift</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub fn practice_run_outcome(mut self, input: crate::types::PracticeRunOutcome) -> Self {
        self.practice_run_outcome = ::std::option::Option::Some(input);
        self
    }
    /// <p>The outcome, or end state, returned for a practice run. The following values can be returned:</p>
    /// <ul>
    /// <li>
    /// <p><b>PENDING:</b> Outcome value when a practice run is in progress.</p></li>
    /// <li>
    /// <p><b>SUCCEEDED:</b> Outcome value when the outcome alarm specified for the practice run configuration does not go into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed the expected 30 minute zonal shift.</p></li>
    /// <li>
    /// <p><b>INTERRUPTED:</b> Outcome value when the practice run was stopped before the expected 30 minute zonal shift duration, or there was another problem with the practice run that created an inconclusive outcome.</p></li>
    /// <li>
    /// <p><b>FAILED:</b> Outcome value when the outcome alarm specified for the practice run configuration goes into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed.</p></li>
    /// </ul>
    /// <p>For more information about practice run outcomes, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html"> Considerations when you configure zonal autoshift</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub fn set_practice_run_outcome(mut self, input: ::std::option::Option<crate::types::PracticeRunOutcome>) -> Self {
        self.practice_run_outcome = input;
        self
    }
    /// <p>The outcome, or end state, returned for a practice run. The following values can be returned:</p>
    /// <ul>
    /// <li>
    /// <p><b>PENDING:</b> Outcome value when a practice run is in progress.</p></li>
    /// <li>
    /// <p><b>SUCCEEDED:</b> Outcome value when the outcome alarm specified for the practice run configuration does not go into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed the expected 30 minute zonal shift.</p></li>
    /// <li>
    /// <p><b>INTERRUPTED:</b> Outcome value when the practice run was stopped before the expected 30 minute zonal shift duration, or there was another problem with the practice run that created an inconclusive outcome.</p></li>
    /// <li>
    /// <p><b>FAILED:</b> Outcome value when the outcome alarm specified for the practice run configuration goes into an <code>ALARM</code> state during the practice run, and the practice run was not interrupted before it completed.</p></li>
    /// </ul>
    /// <p>For more information about practice run outcomes, see <a href="https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html"> Considerations when you configure zonal autoshift</a> in the Amazon Route 53 Application Recovery Controller Developer Guide.</p>
    pub fn get_practice_run_outcome(&self) -> &::std::option::Option<crate::types::PracticeRunOutcome> {
        &self.practice_run_outcome
    }
    /// Consumes the builder and constructs a [`ZonalShiftInResource`](crate::types::ZonalShiftInResource).
    /// This method will fail if any of the following fields are not set:
    /// - [`applied_status`](crate::types::builders::ZonalShiftInResourceBuilder::applied_status)
    /// - [`zonal_shift_id`](crate::types::builders::ZonalShiftInResourceBuilder::zonal_shift_id)
    /// - [`resource_identifier`](crate::types::builders::ZonalShiftInResourceBuilder::resource_identifier)
    /// - [`away_from`](crate::types::builders::ZonalShiftInResourceBuilder::away_from)
    /// - [`expiry_time`](crate::types::builders::ZonalShiftInResourceBuilder::expiry_time)
    /// - [`start_time`](crate::types::builders::ZonalShiftInResourceBuilder::start_time)
    /// - [`comment`](crate::types::builders::ZonalShiftInResourceBuilder::comment)
    pub fn build(self) -> ::std::result::Result<crate::types::ZonalShiftInResource, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::ZonalShiftInResource {
            applied_status: self.applied_status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "applied_status",
                    "applied_status was not specified but it is required when building ZonalShiftInResource",
                )
            })?,
            zonal_shift_id: self.zonal_shift_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "zonal_shift_id",
                    "zonal_shift_id was not specified but it is required when building ZonalShiftInResource",
                )
            })?,
            resource_identifier: self.resource_identifier.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "resource_identifier",
                    "resource_identifier was not specified but it is required when building ZonalShiftInResource",
                )
            })?,
            away_from: self.away_from.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "away_from",
                    "away_from was not specified but it is required when building ZonalShiftInResource",
                )
            })?,
            expiry_time: self.expiry_time.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "expiry_time",
                    "expiry_time was not specified but it is required when building ZonalShiftInResource",
                )
            })?,
            start_time: self.start_time.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "start_time",
                    "start_time was not specified but it is required when building ZonalShiftInResource",
                )
            })?,
            comment: self.comment.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "comment",
                    "comment was not specified but it is required when building ZonalShiftInResource",
                )
            })?,
            practice_run_outcome: self.practice_run_outcome,
        })
    }
}
