// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A subset of terms proposed by the proposer, which have been accepted by the acceptor as part of agreement creation.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum AcceptedTerm {
    /// <p>Enables you and your customers to move your existing agreements to AWS Marketplace. The customer won't be charged for product usage in AWS Marketplace because they already paid for the product outside of AWS Marketplace.</p>
    ByolPricingTerm(crate::types::ByolPricingTerm),
    /// <p>Defines a prepaid payment model that allows buyers to configure the entitlements they want to purchase and the duration.</p>
    ConfigurableUpfrontPricingTerm(crate::types::ConfigurableUpfrontPricingTerm),
    /// <p>Defines a pre-paid pricing model where the customers are charged a fixed upfront amount.</p>
    FixedUpfrontPricingTerm(crate::types::FixedUpfrontPricingTerm),
    /// <p>Defines a short-term free pricing model where the buyers arenâ€™t charged anything within a specified limit.</p>
    FreeTrialPricingTerm(crate::types::FreeTrialPricingTerm),
    /// <p>Defines the list of text agreements proposed to the acceptors. An example is the end user license agreement (EULA).</p>
    LegalTerm(crate::types::LegalTerm),
    /// <p>Defines an installment-based pricing model where customers are charged a fixed price on different dates during the agreement validity period. This is used most commonly for flexible payment schedule pricing.</p>
    PaymentScheduleTerm(crate::types::PaymentScheduleTerm),
    /// <p>Defines a pricing model where customers are charged a fixed recurring price at the end of each billing period.</p>
    RecurringPaymentTerm(crate::types::RecurringPaymentTerm),
    /// <p>Defines that on graceful expiration of the agreement (when the agreement ends on its pre-defined end date), a new agreement will be created using the accepted terms on the existing agreement. In other words, the agreement will be renewed. Presence of <code>RenewalTerm</code> in the offer document means that auto-renewal is allowed. Buyers will have the option to accept or decline auto-renewal at the offer acceptance/agreement creation. Buyers can also change this flag from <code>True</code> to <code>False</code> or <code>False</code> to <code>True</code> at anytime during the agreement's lifecycle.</p>
    RenewalTerm(crate::types::RenewalTerm),
    /// <p>Defines the customer support available for the acceptors when they purchase the software.</p>
    SupportTerm(crate::types::SupportTerm),
    /// <p>Defines a usage-based pricing model (typically, pay-as-you-go pricing), where the customers are charged based on product usage.</p>
    UsageBasedPricingTerm(crate::types::UsageBasedPricingTerm),
    /// <p>Defines the conditions that will keep an agreement created from this offer valid.</p>
    ValidityTerm(crate::types::ValidityTerm),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl AcceptedTerm {
    /// Tries to convert the enum instance into [`ByolPricingTerm`](crate::types::AcceptedTerm::ByolPricingTerm), extracting the inner [`ByolPricingTerm`](crate::types::ByolPricingTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_byol_pricing_term(&self) -> ::std::result::Result<&crate::types::ByolPricingTerm, &Self> {
        if let AcceptedTerm::ByolPricingTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`ByolPricingTerm`](crate::types::AcceptedTerm::ByolPricingTerm).
    pub fn is_byol_pricing_term(&self) -> bool {
        self.as_byol_pricing_term().is_ok()
    }
    /// Tries to convert the enum instance into [`ConfigurableUpfrontPricingTerm`](crate::types::AcceptedTerm::ConfigurableUpfrontPricingTerm), extracting the inner [`ConfigurableUpfrontPricingTerm`](crate::types::ConfigurableUpfrontPricingTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_configurable_upfront_pricing_term(&self) -> ::std::result::Result<&crate::types::ConfigurableUpfrontPricingTerm, &Self> {
        if let AcceptedTerm::ConfigurableUpfrontPricingTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`ConfigurableUpfrontPricingTerm`](crate::types::AcceptedTerm::ConfigurableUpfrontPricingTerm).
    pub fn is_configurable_upfront_pricing_term(&self) -> bool {
        self.as_configurable_upfront_pricing_term().is_ok()
    }
    /// Tries to convert the enum instance into [`FixedUpfrontPricingTerm`](crate::types::AcceptedTerm::FixedUpfrontPricingTerm), extracting the inner [`FixedUpfrontPricingTerm`](crate::types::FixedUpfrontPricingTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_fixed_upfront_pricing_term(&self) -> ::std::result::Result<&crate::types::FixedUpfrontPricingTerm, &Self> {
        if let AcceptedTerm::FixedUpfrontPricingTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`FixedUpfrontPricingTerm`](crate::types::AcceptedTerm::FixedUpfrontPricingTerm).
    pub fn is_fixed_upfront_pricing_term(&self) -> bool {
        self.as_fixed_upfront_pricing_term().is_ok()
    }
    /// Tries to convert the enum instance into [`FreeTrialPricingTerm`](crate::types::AcceptedTerm::FreeTrialPricingTerm), extracting the inner [`FreeTrialPricingTerm`](crate::types::FreeTrialPricingTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_free_trial_pricing_term(&self) -> ::std::result::Result<&crate::types::FreeTrialPricingTerm, &Self> {
        if let AcceptedTerm::FreeTrialPricingTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`FreeTrialPricingTerm`](crate::types::AcceptedTerm::FreeTrialPricingTerm).
    pub fn is_free_trial_pricing_term(&self) -> bool {
        self.as_free_trial_pricing_term().is_ok()
    }
    /// Tries to convert the enum instance into [`LegalTerm`](crate::types::AcceptedTerm::LegalTerm), extracting the inner [`LegalTerm`](crate::types::LegalTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_legal_term(&self) -> ::std::result::Result<&crate::types::LegalTerm, &Self> {
        if let AcceptedTerm::LegalTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`LegalTerm`](crate::types::AcceptedTerm::LegalTerm).
    pub fn is_legal_term(&self) -> bool {
        self.as_legal_term().is_ok()
    }
    /// Tries to convert the enum instance into [`PaymentScheduleTerm`](crate::types::AcceptedTerm::PaymentScheduleTerm), extracting the inner [`PaymentScheduleTerm`](crate::types::PaymentScheduleTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_payment_schedule_term(&self) -> ::std::result::Result<&crate::types::PaymentScheduleTerm, &Self> {
        if let AcceptedTerm::PaymentScheduleTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`PaymentScheduleTerm`](crate::types::AcceptedTerm::PaymentScheduleTerm).
    pub fn is_payment_schedule_term(&self) -> bool {
        self.as_payment_schedule_term().is_ok()
    }
    /// Tries to convert the enum instance into [`RecurringPaymentTerm`](crate::types::AcceptedTerm::RecurringPaymentTerm), extracting the inner [`RecurringPaymentTerm`](crate::types::RecurringPaymentTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_recurring_payment_term(&self) -> ::std::result::Result<&crate::types::RecurringPaymentTerm, &Self> {
        if let AcceptedTerm::RecurringPaymentTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`RecurringPaymentTerm`](crate::types::AcceptedTerm::RecurringPaymentTerm).
    pub fn is_recurring_payment_term(&self) -> bool {
        self.as_recurring_payment_term().is_ok()
    }
    /// Tries to convert the enum instance into [`RenewalTerm`](crate::types::AcceptedTerm::RenewalTerm), extracting the inner [`RenewalTerm`](crate::types::RenewalTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_renewal_term(&self) -> ::std::result::Result<&crate::types::RenewalTerm, &Self> {
        if let AcceptedTerm::RenewalTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`RenewalTerm`](crate::types::AcceptedTerm::RenewalTerm).
    pub fn is_renewal_term(&self) -> bool {
        self.as_renewal_term().is_ok()
    }
    /// Tries to convert the enum instance into [`SupportTerm`](crate::types::AcceptedTerm::SupportTerm), extracting the inner [`SupportTerm`](crate::types::SupportTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_support_term(&self) -> ::std::result::Result<&crate::types::SupportTerm, &Self> {
        if let AcceptedTerm::SupportTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`SupportTerm`](crate::types::AcceptedTerm::SupportTerm).
    pub fn is_support_term(&self) -> bool {
        self.as_support_term().is_ok()
    }
    /// Tries to convert the enum instance into [`UsageBasedPricingTerm`](crate::types::AcceptedTerm::UsageBasedPricingTerm), extracting the inner [`UsageBasedPricingTerm`](crate::types::UsageBasedPricingTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_usage_based_pricing_term(&self) -> ::std::result::Result<&crate::types::UsageBasedPricingTerm, &Self> {
        if let AcceptedTerm::UsageBasedPricingTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`UsageBasedPricingTerm`](crate::types::AcceptedTerm::UsageBasedPricingTerm).
    pub fn is_usage_based_pricing_term(&self) -> bool {
        self.as_usage_based_pricing_term().is_ok()
    }
    /// Tries to convert the enum instance into [`ValidityTerm`](crate::types::AcceptedTerm::ValidityTerm), extracting the inner [`ValidityTerm`](crate::types::ValidityTerm).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_validity_term(&self) -> ::std::result::Result<&crate::types::ValidityTerm, &Self> {
        if let AcceptedTerm::ValidityTerm(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`ValidityTerm`](crate::types::AcceptedTerm::ValidityTerm).
    pub fn is_validity_term(&self) -> bool {
        self.as_validity_term().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}
