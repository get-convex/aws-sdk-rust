// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A collection of kdb dataview entries.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct KxDataviewListEntry {
    /// <p>A unique identifier for the kdb environment.</p>
    pub environment_id: ::std::option::Option<::std::string::String>,
    /// <p>A unique identifier of the database.</p>
    pub database_name: ::std::option::Option<::std::string::String>,
    /// <p>A unique identifier of the dataview.</p>
    pub dataview_name: ::std::option::Option<::std::string::String>,
    /// <p>The number of availability zones you want to assign per cluster. This can be one of the following</p>
    /// <ul>
    /// <li>
    /// <p><code>SINGLE</code> – Assigns one availability zone per cluster.</p></li>
    /// <li>
    /// <p><code>MULTI</code> – Assigns all the availability zones per cluster.</p></li>
    /// </ul>
    pub az_mode: ::std::option::Option<crate::types::KxAzMode>,
    /// <p>The identifier of the availability zones.</p>
    pub availability_zone_id: ::std::option::Option<::std::string::String>,
    /// <p>A unique identifier for the changeset.</p>
    pub changeset_id: ::std::option::Option<::std::string::String>,
    /// <p>The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.</p>
    pub segment_configurations: ::std::option::Option<::std::vec::Vec<crate::types::KxDataviewSegmentConfiguration>>,
    /// <p>The active changeset versions for the given dataview entry.</p>
    pub active_versions: ::std::option::Option<::std::vec::Vec<crate::types::KxDataviewActiveVersion>>,
    /// <p>The status of a given dataview entry.</p>
    pub status: ::std::option::Option<crate::types::KxDataviewStatus>,
    /// <p>A description for the dataview list entry.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.</p>
    pub auto_update: bool,
    /// <p>The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub created_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub last_modified_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The error message when a failed state occurs.</p>
    pub status_reason: ::std::option::Option<::std::string::String>,
}
impl KxDataviewListEntry {
    /// <p>A unique identifier for the kdb environment.</p>
    pub fn environment_id(&self) -> ::std::option::Option<&str> {
        self.environment_id.as_deref()
    }
    /// <p>A unique identifier of the database.</p>
    pub fn database_name(&self) -> ::std::option::Option<&str> {
        self.database_name.as_deref()
    }
    /// <p>A unique identifier of the dataview.</p>
    pub fn dataview_name(&self) -> ::std::option::Option<&str> {
        self.dataview_name.as_deref()
    }
    /// <p>The number of availability zones you want to assign per cluster. This can be one of the following</p>
    /// <ul>
    /// <li>
    /// <p><code>SINGLE</code> – Assigns one availability zone per cluster.</p></li>
    /// <li>
    /// <p><code>MULTI</code> – Assigns all the availability zones per cluster.</p></li>
    /// </ul>
    pub fn az_mode(&self) -> ::std::option::Option<&crate::types::KxAzMode> {
        self.az_mode.as_ref()
    }
    /// <p>The identifier of the availability zones.</p>
    pub fn availability_zone_id(&self) -> ::std::option::Option<&str> {
        self.availability_zone_id.as_deref()
    }
    /// <p>A unique identifier for the changeset.</p>
    pub fn changeset_id(&self) -> ::std::option::Option<&str> {
        self.changeset_id.as_deref()
    }
    /// <p>The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.segment_configurations.is_none()`.
    pub fn segment_configurations(&self) -> &[crate::types::KxDataviewSegmentConfiguration] {
        self.segment_configurations.as_deref().unwrap_or_default()
    }
    /// <p>The active changeset versions for the given dataview entry.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.active_versions.is_none()`.
    pub fn active_versions(&self) -> &[crate::types::KxDataviewActiveVersion] {
        self.active_versions.as_deref().unwrap_or_default()
    }
    /// <p>The status of a given dataview entry.</p>
    pub fn status(&self) -> ::std::option::Option<&crate::types::KxDataviewStatus> {
        self.status.as_ref()
    }
    /// <p>A description for the dataview list entry.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.</p>
    pub fn auto_update(&self) -> bool {
        self.auto_update
    }
    /// <p>The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn created_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_timestamp.as_ref()
    }
    /// <p>The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn last_modified_timestamp(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_modified_timestamp.as_ref()
    }
    /// <p>The error message when a failed state occurs.</p>
    pub fn status_reason(&self) -> ::std::option::Option<&str> {
        self.status_reason.as_deref()
    }
}
impl KxDataviewListEntry {
    /// Creates a new builder-style object to manufacture [`KxDataviewListEntry`](crate::types::KxDataviewListEntry).
    pub fn builder() -> crate::types::builders::KxDataviewListEntryBuilder {
        crate::types::builders::KxDataviewListEntryBuilder::default()
    }
}

/// A builder for [`KxDataviewListEntry`](crate::types::KxDataviewListEntry).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct KxDataviewListEntryBuilder {
    pub(crate) environment_id: ::std::option::Option<::std::string::String>,
    pub(crate) database_name: ::std::option::Option<::std::string::String>,
    pub(crate) dataview_name: ::std::option::Option<::std::string::String>,
    pub(crate) az_mode: ::std::option::Option<crate::types::KxAzMode>,
    pub(crate) availability_zone_id: ::std::option::Option<::std::string::String>,
    pub(crate) changeset_id: ::std::option::Option<::std::string::String>,
    pub(crate) segment_configurations: ::std::option::Option<::std::vec::Vec<crate::types::KxDataviewSegmentConfiguration>>,
    pub(crate) active_versions: ::std::option::Option<::std::vec::Vec<crate::types::KxDataviewActiveVersion>>,
    pub(crate) status: ::std::option::Option<crate::types::KxDataviewStatus>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) auto_update: ::std::option::Option<bool>,
    pub(crate) created_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) last_modified_timestamp: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) status_reason: ::std::option::Option<::std::string::String>,
}
impl KxDataviewListEntryBuilder {
    /// <p>A unique identifier for the kdb environment.</p>
    pub fn environment_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.environment_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the kdb environment.</p>
    pub fn set_environment_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.environment_id = input;
        self
    }
    /// <p>A unique identifier for the kdb environment.</p>
    pub fn get_environment_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.environment_id
    }
    /// <p>A unique identifier of the database.</p>
    pub fn database_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier of the database.</p>
    pub fn set_database_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database_name = input;
        self
    }
    /// <p>A unique identifier of the database.</p>
    pub fn get_database_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.database_name
    }
    /// <p>A unique identifier of the dataview.</p>
    pub fn dataview_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.dataview_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier of the dataview.</p>
    pub fn set_dataview_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.dataview_name = input;
        self
    }
    /// <p>A unique identifier of the dataview.</p>
    pub fn get_dataview_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.dataview_name
    }
    /// <p>The number of availability zones you want to assign per cluster. This can be one of the following</p>
    /// <ul>
    /// <li>
    /// <p><code>SINGLE</code> – Assigns one availability zone per cluster.</p></li>
    /// <li>
    /// <p><code>MULTI</code> – Assigns all the availability zones per cluster.</p></li>
    /// </ul>
    pub fn az_mode(mut self, input: crate::types::KxAzMode) -> Self {
        self.az_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of availability zones you want to assign per cluster. This can be one of the following</p>
    /// <ul>
    /// <li>
    /// <p><code>SINGLE</code> – Assigns one availability zone per cluster.</p></li>
    /// <li>
    /// <p><code>MULTI</code> – Assigns all the availability zones per cluster.</p></li>
    /// </ul>
    pub fn set_az_mode(mut self, input: ::std::option::Option<crate::types::KxAzMode>) -> Self {
        self.az_mode = input;
        self
    }
    /// <p>The number of availability zones you want to assign per cluster. This can be one of the following</p>
    /// <ul>
    /// <li>
    /// <p><code>SINGLE</code> – Assigns one availability zone per cluster.</p></li>
    /// <li>
    /// <p><code>MULTI</code> – Assigns all the availability zones per cluster.</p></li>
    /// </ul>
    pub fn get_az_mode(&self) -> &::std::option::Option<crate::types::KxAzMode> {
        &self.az_mode
    }
    /// <p>The identifier of the availability zones.</p>
    pub fn availability_zone_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.availability_zone_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the availability zones.</p>
    pub fn set_availability_zone_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.availability_zone_id = input;
        self
    }
    /// <p>The identifier of the availability zones.</p>
    pub fn get_availability_zone_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.availability_zone_id
    }
    /// <p>A unique identifier for the changeset.</p>
    pub fn changeset_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.changeset_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for the changeset.</p>
    pub fn set_changeset_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.changeset_id = input;
        self
    }
    /// <p>A unique identifier for the changeset.</p>
    pub fn get_changeset_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.changeset_id
    }
    /// Appends an item to `segment_configurations`.
    ///
    /// To override the contents of this collection use [`set_segment_configurations`](Self::set_segment_configurations).
    ///
    /// <p>The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.</p>
    pub fn segment_configurations(mut self, input: crate::types::KxDataviewSegmentConfiguration) -> Self {
        let mut v = self.segment_configurations.unwrap_or_default();
        v.push(input);
        self.segment_configurations = ::std::option::Option::Some(v);
        self
    }
    /// <p>The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.</p>
    pub fn set_segment_configurations(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::KxDataviewSegmentConfiguration>>) -> Self {
        self.segment_configurations = input;
        self
    }
    /// <p>The configuration that contains the database path of the data that you want to place on each selected volume. Each segment must have a unique database path for each volume. If you do not explicitly specify any database path for a volume, they are accessible from the cluster through the default S3/object store segment.</p>
    pub fn get_segment_configurations(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::KxDataviewSegmentConfiguration>> {
        &self.segment_configurations
    }
    /// Appends an item to `active_versions`.
    ///
    /// To override the contents of this collection use [`set_active_versions`](Self::set_active_versions).
    ///
    /// <p>The active changeset versions for the given dataview entry.</p>
    pub fn active_versions(mut self, input: crate::types::KxDataviewActiveVersion) -> Self {
        let mut v = self.active_versions.unwrap_or_default();
        v.push(input);
        self.active_versions = ::std::option::Option::Some(v);
        self
    }
    /// <p>The active changeset versions for the given dataview entry.</p>
    pub fn set_active_versions(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::KxDataviewActiveVersion>>) -> Self {
        self.active_versions = input;
        self
    }
    /// <p>The active changeset versions for the given dataview entry.</p>
    pub fn get_active_versions(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::KxDataviewActiveVersion>> {
        &self.active_versions
    }
    /// <p>The status of a given dataview entry.</p>
    pub fn status(mut self, input: crate::types::KxDataviewStatus) -> Self {
        self.status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The status of a given dataview entry.</p>
    pub fn set_status(mut self, input: ::std::option::Option<crate::types::KxDataviewStatus>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of a given dataview entry.</p>
    pub fn get_status(&self) -> &::std::option::Option<crate::types::KxDataviewStatus> {
        &self.status
    }
    /// <p>A description for the dataview list entry.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A description for the dataview list entry.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>A description for the dataview list entry.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.</p>
    pub fn auto_update(mut self, input: bool) -> Self {
        self.auto_update = ::std::option::Option::Some(input);
        self
    }
    /// <p>The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.</p>
    pub fn set_auto_update(mut self, input: ::std::option::Option<bool>) -> Self {
        self.auto_update = input;
        self
    }
    /// <p>The option to specify whether you want to apply all the future additions and corrections automatically to the dataview when you ingest new changesets. The default value is false.</p>
    pub fn get_auto_update(&self) -> &::std::option::Option<bool> {
        &self.auto_update
    }
    /// <p>The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn created_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn set_created_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_timestamp = input;
        self
    }
    /// <p>The timestamp at which the dataview list entry was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn get_created_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_timestamp
    }
    /// <p>The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn last_modified_timestamp(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.last_modified_timestamp = ::std::option::Option::Some(input);
        self
    }
    /// <p>The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn set_last_modified_timestamp(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.last_modified_timestamp = input;
        self
    }
    /// <p>The last time that the dataview list was updated in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn get_last_modified_timestamp(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.last_modified_timestamp
    }
    /// <p>The error message when a failed state occurs.</p>
    pub fn status_reason(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status_reason = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The error message when a failed state occurs.</p>
    pub fn set_status_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status_reason = input;
        self
    }
    /// <p>The error message when a failed state occurs.</p>
    pub fn get_status_reason(&self) -> &::std::option::Option<::std::string::String> {
        &self.status_reason
    }
    /// Consumes the builder and constructs a [`KxDataviewListEntry`](crate::types::KxDataviewListEntry).
    pub fn build(self) -> crate::types::KxDataviewListEntry {
        crate::types::KxDataviewListEntry {
            environment_id: self.environment_id,
            database_name: self.database_name,
            dataview_name: self.dataview_name,
            az_mode: self.az_mode,
            availability_zone_id: self.availability_zone_id,
            changeset_id: self.changeset_id,
            segment_configurations: self.segment_configurations,
            active_versions: self.active_versions,
            status: self.status,
            description: self.description,
            auto_update: self.auto_update.unwrap_or_default(),
            created_timestamp: self.created_timestamp,
            last_modified_timestamp: self.last_modified_timestamp,
            status_reason: self.status_reason,
        }
    }
}
