// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreatePrivacyBudgetTemplateInput {
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    pub membership_identifier: ::std::option::Option<::std::string::String>,
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    pub auto_refresh: ::std::option::Option<crate::types::PrivacyBudgetTemplateAutoRefresh>,
    /// <p>Specifies the type of the privacy budget template.</p>
    pub privacy_budget_type: ::std::option::Option<crate::types::PrivacyBudgetType>,
    /// <p>Specifies your parameters for the privacy budget template.</p>
    pub parameters: ::std::option::Option<crate::types::PrivacyBudgetTemplateParametersInput>,
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreatePrivacyBudgetTemplateInput {
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    pub fn membership_identifier(&self) -> ::std::option::Option<&str> {
        self.membership_identifier.as_deref()
    }
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    pub fn auto_refresh(&self) -> ::std::option::Option<&crate::types::PrivacyBudgetTemplateAutoRefresh> {
        self.auto_refresh.as_ref()
    }
    /// <p>Specifies the type of the privacy budget template.</p>
    pub fn privacy_budget_type(&self) -> ::std::option::Option<&crate::types::PrivacyBudgetType> {
        self.privacy_budget_type.as_ref()
    }
    /// <p>Specifies your parameters for the privacy budget template.</p>
    pub fn parameters(&self) -> ::std::option::Option<&crate::types::PrivacyBudgetTemplateParametersInput> {
        self.parameters.as_ref()
    }
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
}
impl CreatePrivacyBudgetTemplateInput {
    /// Creates a new builder-style object to manufacture [`CreatePrivacyBudgetTemplateInput`](crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateInput).
    pub fn builder() -> crate::operation::create_privacy_budget_template::builders::CreatePrivacyBudgetTemplateInputBuilder {
        crate::operation::create_privacy_budget_template::builders::CreatePrivacyBudgetTemplateInputBuilder::default()
    }
}

/// A builder for [`CreatePrivacyBudgetTemplateInput`](crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CreatePrivacyBudgetTemplateInputBuilder {
    pub(crate) membership_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) auto_refresh: ::std::option::Option<crate::types::PrivacyBudgetTemplateAutoRefresh>,
    pub(crate) privacy_budget_type: ::std::option::Option<crate::types::PrivacyBudgetType>,
    pub(crate) parameters: ::std::option::Option<crate::types::PrivacyBudgetTemplateParametersInput>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl CreatePrivacyBudgetTemplateInputBuilder {
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    /// This field is required.
    pub fn membership_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.membership_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    pub fn set_membership_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.membership_identifier = input;
        self
    }
    /// <p>A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.</p>
    pub fn get_membership_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.membership_identifier
    }
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    /// This field is required.
    pub fn auto_refresh(mut self, input: crate::types::PrivacyBudgetTemplateAutoRefresh) -> Self {
        self.auto_refresh = ::std::option::Option::Some(input);
        self
    }
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    pub fn set_auto_refresh(mut self, input: ::std::option::Option<crate::types::PrivacyBudgetTemplateAutoRefresh>) -> Self {
        self.auto_refresh = input;
        self
    }
    /// <p>How often the privacy budget refreshes.</p><important>
    /// <p>If you plan to regularly bring new data into the collaboration, you can use <code>CALENDAR_MONTH</code> to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.</p>
    /// </important>
    pub fn get_auto_refresh(&self) -> &::std::option::Option<crate::types::PrivacyBudgetTemplateAutoRefresh> {
        &self.auto_refresh
    }
    /// <p>Specifies the type of the privacy budget template.</p>
    /// This field is required.
    pub fn privacy_budget_type(mut self, input: crate::types::PrivacyBudgetType) -> Self {
        self.privacy_budget_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the type of the privacy budget template.</p>
    pub fn set_privacy_budget_type(mut self, input: ::std::option::Option<crate::types::PrivacyBudgetType>) -> Self {
        self.privacy_budget_type = input;
        self
    }
    /// <p>Specifies the type of the privacy budget template.</p>
    pub fn get_privacy_budget_type(&self) -> &::std::option::Option<crate::types::PrivacyBudgetType> {
        &self.privacy_budget_type
    }
    /// <p>Specifies your parameters for the privacy budget template.</p>
    /// This field is required.
    pub fn parameters(mut self, input: crate::types::PrivacyBudgetTemplateParametersInput) -> Self {
        self.parameters = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies your parameters for the privacy budget template.</p>
    pub fn set_parameters(mut self, input: ::std::option::Option<crate::types::PrivacyBudgetTemplateParametersInput>) -> Self {
        self.parameters = input;
        self
    }
    /// <p>Specifies your parameters for the privacy budget template.</p>
    pub fn get_parameters(&self) -> &::std::option::Option<crate::types::PrivacyBudgetTemplateParametersInput> {
        &self.parameters
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// Consumes the builder and constructs a [`CreatePrivacyBudgetTemplateInput`](crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateInput,
        ::aws_smithy_types::error::operation::BuildError,
    > {
        ::std::result::Result::Ok(crate::operation::create_privacy_budget_template::CreatePrivacyBudgetTemplateInput {
            membership_identifier: self.membership_identifier,
            auto_refresh: self.auto_refresh,
            privacy_budget_type: self.privacy_budget_type,
            parameters: self.parameters,
            tags: self.tags,
        })
    }
}
