// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>A structure that contains some information about a private re:Post in the account.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct SpaceData {
    /// <p>The unique ID of the private re:Post.</p>
    pub space_id: ::std::string::String,
    /// <p>The ARN of the private re:Post.</p>
    pub arn: ::std::string::String,
    /// <p>The name for the private re:Post.</p>
    pub name: ::std::string::String,
    /// <p>The description for the private re:Post. This is used only to help you identify this private re:Post.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The creation/deletion status of the private re:Post.</p>
    pub status: ::std::string::String,
    /// <p>The configuration status of the private re:Post.</p>
    pub configuration_status: crate::types::ConfigurationStatus,
    /// <p>This approval status of the custom subdomain.</p>
    pub vanity_domain_status: crate::types::VanityDomainStatus,
    /// <p>This custom subdomain that you use to access your private re:Post. All custom subdomains must be approved by AWS before use.</p>
    pub vanity_domain: ::std::string::String,
    /// <p>The AWS generated subdomain of the private re:Post.</p>
    pub random_domain: ::std::string::String,
    /// <p>The pricing tier of the private re:Post.</p>
    pub tier: crate::types::TierLevel,
    /// <p>The storage limit of the private re:Post.</p>
    pub storage_limit: i64,
    /// <p>The date when the private re:Post was created.</p>
    pub create_date_time: ::aws_smithy_types::DateTime,
    /// <p>The date when the private re:Post was deleted.</p>
    pub delete_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The custom AWS KMS key ARN that’s used for the AWS KMS encryption.</p>
    pub user_kms_key: ::std::option::Option<::std::string::String>,
    /// <p>The number of onboarded users to the private re:Post.</p>
    pub user_count: ::std::option::Option<i32>,
    /// <p>The content size of the private re:Post.</p>
    pub content_size: ::std::option::Option<i64>,
}
impl SpaceData {
    /// <p>The unique ID of the private re:Post.</p>
    pub fn space_id(&self) -> &str {
        use std::ops::Deref;
        self.space_id.deref()
    }
    /// <p>The ARN of the private re:Post.</p>
    pub fn arn(&self) -> &str {
        use std::ops::Deref;
        self.arn.deref()
    }
    /// <p>The name for the private re:Post.</p>
    pub fn name(&self) -> &str {
        use std::ops::Deref;
        self.name.deref()
    }
    /// <p>The description for the private re:Post. This is used only to help you identify this private re:Post.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The creation/deletion status of the private re:Post.</p>
    pub fn status(&self) -> &str {
        use std::ops::Deref;
        self.status.deref()
    }
    /// <p>The configuration status of the private re:Post.</p>
    pub fn configuration_status(&self) -> &crate::types::ConfigurationStatus {
        &self.configuration_status
    }
    /// <p>This approval status of the custom subdomain.</p>
    pub fn vanity_domain_status(&self) -> &crate::types::VanityDomainStatus {
        &self.vanity_domain_status
    }
    /// <p>This custom subdomain that you use to access your private re:Post. All custom subdomains must be approved by AWS before use.</p>
    pub fn vanity_domain(&self) -> &str {
        use std::ops::Deref;
        self.vanity_domain.deref()
    }
    /// <p>The AWS generated subdomain of the private re:Post.</p>
    pub fn random_domain(&self) -> &str {
        use std::ops::Deref;
        self.random_domain.deref()
    }
    /// <p>The pricing tier of the private re:Post.</p>
    pub fn tier(&self) -> &crate::types::TierLevel {
        &self.tier
    }
    /// <p>The storage limit of the private re:Post.</p>
    pub fn storage_limit(&self) -> i64 {
        self.storage_limit
    }
    /// <p>The date when the private re:Post was created.</p>
    pub fn create_date_time(&self) -> &::aws_smithy_types::DateTime {
        &self.create_date_time
    }
    /// <p>The date when the private re:Post was deleted.</p>
    pub fn delete_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.delete_date_time.as_ref()
    }
    /// <p>The custom AWS KMS key ARN that’s used for the AWS KMS encryption.</p>
    pub fn user_kms_key(&self) -> ::std::option::Option<&str> {
        self.user_kms_key.as_deref()
    }
    /// <p>The number of onboarded users to the private re:Post.</p>
    pub fn user_count(&self) -> ::std::option::Option<i32> {
        self.user_count
    }
    /// <p>The content size of the private re:Post.</p>
    pub fn content_size(&self) -> ::std::option::Option<i64> {
        self.content_size
    }
}
impl ::std::fmt::Debug for SpaceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SpaceData");
        formatter.field("space_id", &self.space_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("status", &self.status);
        formatter.field("configuration_status", &self.configuration_status);
        formatter.field("vanity_domain_status", &self.vanity_domain_status);
        formatter.field("vanity_domain", &self.vanity_domain);
        formatter.field("random_domain", &self.random_domain);
        formatter.field("tier", &self.tier);
        formatter.field("storage_limit", &self.storage_limit);
        formatter.field("create_date_time", &self.create_date_time);
        formatter.field("delete_date_time", &self.delete_date_time);
        formatter.field("user_kms_key", &self.user_kms_key);
        formatter.field("user_count", &self.user_count);
        formatter.field("content_size", &self.content_size);
        formatter.finish()
    }
}
impl SpaceData {
    /// Creates a new builder-style object to manufacture [`SpaceData`](crate::types::SpaceData).
    pub fn builder() -> crate::types::builders::SpaceDataBuilder {
        crate::types::builders::SpaceDataBuilder::default()
    }
}

/// A builder for [`SpaceData`](crate::types::SpaceData).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct SpaceDataBuilder {
    pub(crate) space_id: ::std::option::Option<::std::string::String>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) status: ::std::option::Option<::std::string::String>,
    pub(crate) configuration_status: ::std::option::Option<crate::types::ConfigurationStatus>,
    pub(crate) vanity_domain_status: ::std::option::Option<crate::types::VanityDomainStatus>,
    pub(crate) vanity_domain: ::std::option::Option<::std::string::String>,
    pub(crate) random_domain: ::std::option::Option<::std::string::String>,
    pub(crate) tier: ::std::option::Option<crate::types::TierLevel>,
    pub(crate) storage_limit: ::std::option::Option<i64>,
    pub(crate) create_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) delete_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) user_kms_key: ::std::option::Option<::std::string::String>,
    pub(crate) user_count: ::std::option::Option<i32>,
    pub(crate) content_size: ::std::option::Option<i64>,
}
impl SpaceDataBuilder {
    /// <p>The unique ID of the private re:Post.</p>
    /// This field is required.
    pub fn space_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.space_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique ID of the private re:Post.</p>
    pub fn set_space_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.space_id = input;
        self
    }
    /// <p>The unique ID of the private re:Post.</p>
    pub fn get_space_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.space_id
    }
    /// <p>The ARN of the private re:Post.</p>
    /// This field is required.
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the private re:Post.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input;
        self
    }
    /// <p>The ARN of the private re:Post.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The name for the private re:Post.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name for the private re:Post.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name for the private re:Post.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The description for the private re:Post. This is used only to help you identify this private re:Post.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description for the private re:Post. This is used only to help you identify this private re:Post.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description for the private re:Post. This is used only to help you identify this private re:Post.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The creation/deletion status of the private re:Post.</p>
    /// This field is required.
    pub fn status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The creation/deletion status of the private re:Post.</p>
    pub fn set_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The creation/deletion status of the private re:Post.</p>
    pub fn get_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.status
    }
    /// <p>The configuration status of the private re:Post.</p>
    /// This field is required.
    pub fn configuration_status(mut self, input: crate::types::ConfigurationStatus) -> Self {
        self.configuration_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>The configuration status of the private re:Post.</p>
    pub fn set_configuration_status(mut self, input: ::std::option::Option<crate::types::ConfigurationStatus>) -> Self {
        self.configuration_status = input;
        self
    }
    /// <p>The configuration status of the private re:Post.</p>
    pub fn get_configuration_status(&self) -> &::std::option::Option<crate::types::ConfigurationStatus> {
        &self.configuration_status
    }
    /// <p>This approval status of the custom subdomain.</p>
    /// This field is required.
    pub fn vanity_domain_status(mut self, input: crate::types::VanityDomainStatus) -> Self {
        self.vanity_domain_status = ::std::option::Option::Some(input);
        self
    }
    /// <p>This approval status of the custom subdomain.</p>
    pub fn set_vanity_domain_status(mut self, input: ::std::option::Option<crate::types::VanityDomainStatus>) -> Self {
        self.vanity_domain_status = input;
        self
    }
    /// <p>This approval status of the custom subdomain.</p>
    pub fn get_vanity_domain_status(&self) -> &::std::option::Option<crate::types::VanityDomainStatus> {
        &self.vanity_domain_status
    }
    /// <p>This custom subdomain that you use to access your private re:Post. All custom subdomains must be approved by AWS before use.</p>
    /// This field is required.
    pub fn vanity_domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vanity_domain = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>This custom subdomain that you use to access your private re:Post. All custom subdomains must be approved by AWS before use.</p>
    pub fn set_vanity_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vanity_domain = input;
        self
    }
    /// <p>This custom subdomain that you use to access your private re:Post. All custom subdomains must be approved by AWS before use.</p>
    pub fn get_vanity_domain(&self) -> &::std::option::Option<::std::string::String> {
        &self.vanity_domain
    }
    /// <p>The AWS generated subdomain of the private re:Post.</p>
    /// This field is required.
    pub fn random_domain(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.random_domain = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The AWS generated subdomain of the private re:Post.</p>
    pub fn set_random_domain(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.random_domain = input;
        self
    }
    /// <p>The AWS generated subdomain of the private re:Post.</p>
    pub fn get_random_domain(&self) -> &::std::option::Option<::std::string::String> {
        &self.random_domain
    }
    /// <p>The pricing tier of the private re:Post.</p>
    /// This field is required.
    pub fn tier(mut self, input: crate::types::TierLevel) -> Self {
        self.tier = ::std::option::Option::Some(input);
        self
    }
    /// <p>The pricing tier of the private re:Post.</p>
    pub fn set_tier(mut self, input: ::std::option::Option<crate::types::TierLevel>) -> Self {
        self.tier = input;
        self
    }
    /// <p>The pricing tier of the private re:Post.</p>
    pub fn get_tier(&self) -> &::std::option::Option<crate::types::TierLevel> {
        &self.tier
    }
    /// <p>The storage limit of the private re:Post.</p>
    /// This field is required.
    pub fn storage_limit(mut self, input: i64) -> Self {
        self.storage_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>The storage limit of the private re:Post.</p>
    pub fn set_storage_limit(mut self, input: ::std::option::Option<i64>) -> Self {
        self.storage_limit = input;
        self
    }
    /// <p>The storage limit of the private re:Post.</p>
    pub fn get_storage_limit(&self) -> &::std::option::Option<i64> {
        &self.storage_limit
    }
    /// <p>The date when the private re:Post was created.</p>
    /// This field is required.
    pub fn create_date_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.create_date_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date when the private re:Post was created.</p>
    pub fn set_create_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.create_date_time = input;
        self
    }
    /// <p>The date when the private re:Post was created.</p>
    pub fn get_create_date_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.create_date_time
    }
    /// <p>The date when the private re:Post was deleted.</p>
    pub fn delete_date_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.delete_date_time = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date when the private re:Post was deleted.</p>
    pub fn set_delete_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.delete_date_time = input;
        self
    }
    /// <p>The date when the private re:Post was deleted.</p>
    pub fn get_delete_date_time(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.delete_date_time
    }
    /// <p>The custom AWS KMS key ARN that’s used for the AWS KMS encryption.</p>
    pub fn user_kms_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user_kms_key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The custom AWS KMS key ARN that’s used for the AWS KMS encryption.</p>
    pub fn set_user_kms_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user_kms_key = input;
        self
    }
    /// <p>The custom AWS KMS key ARN that’s used for the AWS KMS encryption.</p>
    pub fn get_user_kms_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.user_kms_key
    }
    /// <p>The number of onboarded users to the private re:Post.</p>
    pub fn user_count(mut self, input: i32) -> Self {
        self.user_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of onboarded users to the private re:Post.</p>
    pub fn set_user_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.user_count = input;
        self
    }
    /// <p>The number of onboarded users to the private re:Post.</p>
    pub fn get_user_count(&self) -> &::std::option::Option<i32> {
        &self.user_count
    }
    /// <p>The content size of the private re:Post.</p>
    pub fn content_size(mut self, input: i64) -> Self {
        self.content_size = ::std::option::Option::Some(input);
        self
    }
    /// <p>The content size of the private re:Post.</p>
    pub fn set_content_size(mut self, input: ::std::option::Option<i64>) -> Self {
        self.content_size = input;
        self
    }
    /// <p>The content size of the private re:Post.</p>
    pub fn get_content_size(&self) -> &::std::option::Option<i64> {
        &self.content_size
    }
    /// Consumes the builder and constructs a [`SpaceData`](crate::types::SpaceData).
    /// This method will fail if any of the following fields are not set:
    /// - [`space_id`](crate::types::builders::SpaceDataBuilder::space_id)
    /// - [`arn`](crate::types::builders::SpaceDataBuilder::arn)
    /// - [`name`](crate::types::builders::SpaceDataBuilder::name)
    /// - [`status`](crate::types::builders::SpaceDataBuilder::status)
    /// - [`configuration_status`](crate::types::builders::SpaceDataBuilder::configuration_status)
    /// - [`vanity_domain_status`](crate::types::builders::SpaceDataBuilder::vanity_domain_status)
    /// - [`vanity_domain`](crate::types::builders::SpaceDataBuilder::vanity_domain)
    /// - [`random_domain`](crate::types::builders::SpaceDataBuilder::random_domain)
    /// - [`tier`](crate::types::builders::SpaceDataBuilder::tier)
    /// - [`storage_limit`](crate::types::builders::SpaceDataBuilder::storage_limit)
    /// - [`create_date_time`](crate::types::builders::SpaceDataBuilder::create_date_time)
    pub fn build(self) -> ::std::result::Result<crate::types::SpaceData, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::SpaceData {
            space_id: self.space_id.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "space_id",
                    "space_id was not specified but it is required when building SpaceData",
                )
            })?,
            arn: self.arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "arn",
                    "arn was not specified but it is required when building SpaceData",
                )
            })?,
            name: self.name.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "name",
                    "name was not specified but it is required when building SpaceData",
                )
            })?,
            description: self.description,
            status: self.status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "status",
                    "status was not specified but it is required when building SpaceData",
                )
            })?,
            configuration_status: self.configuration_status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "configuration_status",
                    "configuration_status was not specified but it is required when building SpaceData",
                )
            })?,
            vanity_domain_status: self.vanity_domain_status.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "vanity_domain_status",
                    "vanity_domain_status was not specified but it is required when building SpaceData",
                )
            })?,
            vanity_domain: self.vanity_domain.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "vanity_domain",
                    "vanity_domain was not specified but it is required when building SpaceData",
                )
            })?,
            random_domain: self.random_domain.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "random_domain",
                    "random_domain was not specified but it is required when building SpaceData",
                )
            })?,
            tier: self.tier.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "tier",
                    "tier was not specified but it is required when building SpaceData",
                )
            })?,
            storage_limit: self.storage_limit.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "storage_limit",
                    "storage_limit was not specified but it is required when building SpaceData",
                )
            })?,
            create_date_time: self.create_date_time.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "create_date_time",
                    "create_date_time was not specified but it is required when building SpaceData",
                )
            })?,
            delete_date_time: self.delete_date_time,
            user_kms_key: self.user_kms_key,
            user_count: self.user_count,
            content_size: self.content_size,
        })
    }
}
impl ::std::fmt::Debug for SpaceDataBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SpaceDataBuilder");
        formatter.field("space_id", &self.space_id);
        formatter.field("arn", &self.arn);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("status", &self.status);
        formatter.field("configuration_status", &self.configuration_status);
        formatter.field("vanity_domain_status", &self.vanity_domain_status);
        formatter.field("vanity_domain", &self.vanity_domain);
        formatter.field("random_domain", &self.random_domain);
        formatter.field("tier", &self.tier);
        formatter.field("storage_limit", &self.storage_limit);
        formatter.field("create_date_time", &self.create_date_time);
        formatter.field("delete_date_time", &self.delete_date_time);
        formatter.field("user_kms_key", &self.user_kms_key);
        formatter.field("user_count", &self.user_count);
        formatter.field("content_size", &self.content_size);
        formatter.finish()
    }
}
