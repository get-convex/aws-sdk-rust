// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Use <code>Expression</code> to filter in the <code>GetFreeTierUsage</code> API operation.</p>
/// <p>You can use the following patterns:</p>
/// <ul>
/// <li>
/// <p>Simple dimension values (<code>Dimensions</code> root operator)</p></li>
/// <li>
/// <p>Complex expressions with logical operators (<code>AND</code>, <code>NOT</code>, and <code>OR</code> root operators).</p></li>
/// </ul>
/// <p>For <i>simple dimension values</i>, you can set the dimension name, values, and match type for the filters that you plan to use.</p>
/// <p><b>Example for simple dimension values</b></p>
/// <p>You can filter to match exactly for <code>REGION==us-east-1 OR REGION==us-west-1</code>.</p>
/// <p>The corresponding <code>Expression</code> appears like the following: <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] } }</code></p>
/// <p>As shown in the previous example, lists of dimension values are combined with <code>OR</code> when you apply the filter.</p>
/// <p>For <i>complex expressions with logical operators</i>, you can have nested expressions to use the logical operators and specify advanced filtering.</p>
/// <p><b>Example for complex expressions with logical operators</b></p>
/// <p>You can filter by <code>((REGION == us-east-1 OR REGION == us-west-1) OR (SERVICE CONTAINS AWSLambda)) AND (USAGE_TYPE !CONTAINS DataTransfer)</code>.</p>
/// <p>The corresponding <code>Expression</code> appears like the following: <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] }}, {"Dimensions": { "Key": "SERVICE", "Values": ["AWSLambda"], "MatchOptions": ["CONTAINS"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"], "MatchOptions": ["CONTAINS"] }}} ] }</code></p>
/// <p>In the following <b>Contents</b>, you must specify exactly one of the following root operators.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Expression {
    /// <p>Return results that match any of the <code>Expressions</code> that you specified. in the array.</p>
    pub or: ::std::option::Option<::std::vec::Vec<crate::types::Expression>>,
    /// <p>Return results that match all <code>Expressions</code> that you specified in the array.</p>
    pub and: ::std::option::Option<::std::vec::Vec<crate::types::Expression>>,
    /// <p>Return results that don’t match the <code>Expression</code> that you specified.</p>
    pub not: ::std::option::Option<::std::boxed::Box<crate::types::Expression>>,
    /// <p>The specific dimension, values, and match type to filter objects with.</p>
    pub dimensions: ::std::option::Option<crate::types::DimensionValues>,
}
impl Expression {
    /// <p>Return results that match any of the <code>Expressions</code> that you specified. in the array.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.or.is_none()`.
    pub fn or(&self) -> &[crate::types::Expression] {
        self.or.as_deref().unwrap_or_default()
    }
    /// <p>Return results that match all <code>Expressions</code> that you specified in the array.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.and.is_none()`.
    pub fn and(&self) -> &[crate::types::Expression] {
        self.and.as_deref().unwrap_or_default()
    }
    /// <p>Return results that don’t match the <code>Expression</code> that you specified.</p>
    pub fn not(&self) -> ::std::option::Option<&crate::types::Expression> {
        self.not.as_deref()
    }
    /// <p>The specific dimension, values, and match type to filter objects with.</p>
    pub fn dimensions(&self) -> ::std::option::Option<&crate::types::DimensionValues> {
        self.dimensions.as_ref()
    }
}
impl Expression {
    /// Creates a new builder-style object to manufacture [`Expression`](crate::types::Expression).
    pub fn builder() -> crate::types::builders::ExpressionBuilder {
        crate::types::builders::ExpressionBuilder::default()
    }
}

/// A builder for [`Expression`](crate::types::Expression).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ExpressionBuilder {
    pub(crate) or: ::std::option::Option<::std::vec::Vec<crate::types::Expression>>,
    pub(crate) and: ::std::option::Option<::std::vec::Vec<crate::types::Expression>>,
    pub(crate) not: ::std::option::Option<::std::boxed::Box<crate::types::Expression>>,
    pub(crate) dimensions: ::std::option::Option<crate::types::DimensionValues>,
}
impl ExpressionBuilder {
    /// Appends an item to `or`.
    ///
    /// To override the contents of this collection use [`set_or`](Self::set_or).
    ///
    /// <p>Return results that match any of the <code>Expressions</code> that you specified. in the array.</p>
    pub fn or(mut self, input: crate::types::Expression) -> Self {
        let mut v = self.or.unwrap_or_default();
        v.push(input);
        self.or = ::std::option::Option::Some(v);
        self
    }
    /// <p>Return results that match any of the <code>Expressions</code> that you specified. in the array.</p>
    pub fn set_or(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Expression>>) -> Self {
        self.or = input;
        self
    }
    /// <p>Return results that match any of the <code>Expressions</code> that you specified. in the array.</p>
    pub fn get_or(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Expression>> {
        &self.or
    }
    /// Appends an item to `and`.
    ///
    /// To override the contents of this collection use [`set_and`](Self::set_and).
    ///
    /// <p>Return results that match all <code>Expressions</code> that you specified in the array.</p>
    pub fn and(mut self, input: crate::types::Expression) -> Self {
        let mut v = self.and.unwrap_or_default();
        v.push(input);
        self.and = ::std::option::Option::Some(v);
        self
    }
    /// <p>Return results that match all <code>Expressions</code> that you specified in the array.</p>
    pub fn set_and(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Expression>>) -> Self {
        self.and = input;
        self
    }
    /// <p>Return results that match all <code>Expressions</code> that you specified in the array.</p>
    pub fn get_and(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Expression>> {
        &self.and
    }
    /// <p>Return results that don’t match the <code>Expression</code> that you specified.</p>
    pub fn not(mut self, input: impl ::std::convert::Into<::std::boxed::Box<crate::types::Expression>>) -> Self {
        self.not = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Return results that don’t match the <code>Expression</code> that you specified.</p>
    pub fn set_not(mut self, input: ::std::option::Option<::std::boxed::Box<crate::types::Expression>>) -> Self {
        self.not = input;
        self
    }
    /// <p>Return results that don’t match the <code>Expression</code> that you specified.</p>
    pub fn get_not(&self) -> &::std::option::Option<::std::boxed::Box<crate::types::Expression>> {
        &self.not
    }
    /// <p>The specific dimension, values, and match type to filter objects with.</p>
    pub fn dimensions(mut self, input: crate::types::DimensionValues) -> Self {
        self.dimensions = ::std::option::Option::Some(input);
        self
    }
    /// <p>The specific dimension, values, and match type to filter objects with.</p>
    pub fn set_dimensions(mut self, input: ::std::option::Option<crate::types::DimensionValues>) -> Self {
        self.dimensions = input;
        self
    }
    /// <p>The specific dimension, values, and match type to filter objects with.</p>
    pub fn get_dimensions(&self) -> &::std::option::Option<crate::types::DimensionValues> {
        &self.dimensions
    }
    /// Consumes the builder and constructs a [`Expression`](crate::types::Expression).
    pub fn build(self) -> crate::types::Expression {
        crate::types::Expression {
            or: self.or,
            and: self.and,
            not: self.not,
            dimensions: self.dimensions,
        }
    }
}
