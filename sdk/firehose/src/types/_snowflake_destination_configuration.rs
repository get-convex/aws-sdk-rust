// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Configure Snowflake destination</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct SnowflakeDestinationConfiguration {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub account_url: ::std::string::String,
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub private_key: ::std::string::String,
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub key_passphrase: ::std::option::Option<::std::string::String>,
    /// <p>User login name for the Snowflake account.</p>
    pub user: ::std::string::String,
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub database: ::std::string::String,
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub schema: ::std::string::String,
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub table: ::std::string::String,
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub snowflake_role_configuration: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>,
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub data_loading_option: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>,
    /// <p>The name of the record metadata column</p>
    pub meta_data_column_name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the record content column</p>
    pub content_column_name: ::std::option::Option<::std::string::String>,
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub snowflake_vpc_configuration: ::std::option::Option<crate::types::SnowflakeVpcConfiguration>,
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub cloud_watch_logging_options: ::std::option::Option<crate::types::CloudWatchLoggingOptions>,
    /// <p>Describes a data processing configuration.</p>
    pub processing_configuration: ::std::option::Option<crate::types::ProcessingConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub role_arn: ::std::string::String,
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub retry_options: ::std::option::Option<crate::types::SnowflakeRetryOptions>,
    /// <p>Choose an S3 backup mode</p>
    pub s3_backup_mode: ::std::option::Option<crate::types::SnowflakeS3BackupMode>,
    /// <p>Describes the configuration of a destination in Amazon S3.</p>
    pub s3_configuration: ::std::option::Option<crate::types::S3DestinationConfiguration>,
}
impl SnowflakeDestinationConfiguration {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn account_url(&self) -> &str {
        use std::ops::Deref;
        self.account_url.deref()
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn private_key(&self) -> &str {
        use std::ops::Deref;
        self.private_key.deref()
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn key_passphrase(&self) -> ::std::option::Option<&str> {
        self.key_passphrase.as_deref()
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn user(&self) -> &str {
        use std::ops::Deref;
        self.user.deref()
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn database(&self) -> &str {
        use std::ops::Deref;
        self.database.deref()
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn schema(&self) -> &str {
        use std::ops::Deref;
        self.schema.deref()
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn table(&self) -> &str {
        use std::ops::Deref;
        self.table.deref()
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn snowflake_role_configuration(&self) -> ::std::option::Option<&crate::types::SnowflakeRoleConfiguration> {
        self.snowflake_role_configuration.as_ref()
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn data_loading_option(&self) -> ::std::option::Option<&crate::types::SnowflakeDataLoadingOption> {
        self.data_loading_option.as_ref()
    }
    /// <p>The name of the record metadata column</p>
    pub fn meta_data_column_name(&self) -> ::std::option::Option<&str> {
        self.meta_data_column_name.as_deref()
    }
    /// <p>The name of the record content column</p>
    pub fn content_column_name(&self) -> ::std::option::Option<&str> {
        self.content_column_name.as_deref()
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn snowflake_vpc_configuration(&self) -> ::std::option::Option<&crate::types::SnowflakeVpcConfiguration> {
        self.snowflake_vpc_configuration.as_ref()
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn cloud_watch_logging_options(&self) -> ::std::option::Option<&crate::types::CloudWatchLoggingOptions> {
        self.cloud_watch_logging_options.as_ref()
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn processing_configuration(&self) -> ::std::option::Option<&crate::types::ProcessingConfiguration> {
        self.processing_configuration.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn role_arn(&self) -> &str {
        use std::ops::Deref;
        self.role_arn.deref()
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn retry_options(&self) -> ::std::option::Option<&crate::types::SnowflakeRetryOptions> {
        self.retry_options.as_ref()
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn s3_backup_mode(&self) -> ::std::option::Option<&crate::types::SnowflakeS3BackupMode> {
        self.s3_backup_mode.as_ref()
    }
    /// <p>Describes the configuration of a destination in Amazon S3.</p>
    pub fn s3_configuration(&self) -> ::std::option::Option<&crate::types::S3DestinationConfiguration> {
        self.s3_configuration.as_ref()
    }
}
impl ::std::fmt::Debug for SnowflakeDestinationConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SnowflakeDestinationConfiguration");
        formatter.field("account_url", &"*** Sensitive Data Redacted ***");
        formatter.field("private_key", &"*** Sensitive Data Redacted ***");
        formatter.field("key_passphrase", &"*** Sensitive Data Redacted ***");
        formatter.field("user", &"*** Sensitive Data Redacted ***");
        formatter.field("database", &"*** Sensitive Data Redacted ***");
        formatter.field("schema", &"*** Sensitive Data Redacted ***");
        formatter.field("table", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_role_configuration", &self.snowflake_role_configuration);
        formatter.field("data_loading_option", &self.data_loading_option);
        formatter.field("meta_data_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("content_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_vpc_configuration", &self.snowflake_vpc_configuration);
        formatter.field("cloud_watch_logging_options", &self.cloud_watch_logging_options);
        formatter.field("processing_configuration", &self.processing_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("retry_options", &self.retry_options);
        formatter.field("s3_backup_mode", &self.s3_backup_mode);
        formatter.field("s3_configuration", &self.s3_configuration);
        formatter.finish()
    }
}
impl SnowflakeDestinationConfiguration {
    /// Creates a new builder-style object to manufacture [`SnowflakeDestinationConfiguration`](crate::types::SnowflakeDestinationConfiguration).
    pub fn builder() -> crate::types::builders::SnowflakeDestinationConfigurationBuilder {
        crate::types::builders::SnowflakeDestinationConfigurationBuilder::default()
    }
}

/// A builder for [`SnowflakeDestinationConfiguration`](crate::types::SnowflakeDestinationConfiguration).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct SnowflakeDestinationConfigurationBuilder {
    pub(crate) account_url: ::std::option::Option<::std::string::String>,
    pub(crate) private_key: ::std::option::Option<::std::string::String>,
    pub(crate) key_passphrase: ::std::option::Option<::std::string::String>,
    pub(crate) user: ::std::option::Option<::std::string::String>,
    pub(crate) database: ::std::option::Option<::std::string::String>,
    pub(crate) schema: ::std::option::Option<::std::string::String>,
    pub(crate) table: ::std::option::Option<::std::string::String>,
    pub(crate) snowflake_role_configuration: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>,
    pub(crate) data_loading_option: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>,
    pub(crate) meta_data_column_name: ::std::option::Option<::std::string::String>,
    pub(crate) content_column_name: ::std::option::Option<::std::string::String>,
    pub(crate) snowflake_vpc_configuration: ::std::option::Option<crate::types::SnowflakeVpcConfiguration>,
    pub(crate) cloud_watch_logging_options: ::std::option::Option<crate::types::CloudWatchLoggingOptions>,
    pub(crate) processing_configuration: ::std::option::Option<crate::types::ProcessingConfiguration>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) retry_options: ::std::option::Option<crate::types::SnowflakeRetryOptions>,
    pub(crate) s3_backup_mode: ::std::option::Option<crate::types::SnowflakeS3BackupMode>,
    pub(crate) s3_configuration: ::std::option::Option<crate::types::S3DestinationConfiguration>,
}
impl SnowflakeDestinationConfigurationBuilder {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    /// This field is required.
    pub fn account_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.account_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn set_account_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.account_url = input;
        self
    }
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn get_account_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.account_url
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    /// This field is required.
    pub fn private_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.private_key = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn set_private_key(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.private_key = input;
        self
    }
    /// <p>The private key used to encrypt your Snowflake client. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn get_private_key(&self) -> &::std::option::Option<::std::string::String> {
        &self.private_key
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn key_passphrase(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.key_passphrase = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn set_key_passphrase(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.key_passphrase = input;
        self
    }
    /// <p>Passphrase to decrypt the private key when the key is encrypted. For information, see <a href="https://docs.snowflake.com/en/user-guide/data-load-snowpipe-streaming-configuration#using-key-pair-authentication-key-rotation">Using Key Pair Authentication &amp; Key Rotation</a>.</p>
    pub fn get_key_passphrase(&self) -> &::std::option::Option<::std::string::String> {
        &self.key_passphrase
    }
    /// <p>User login name for the Snowflake account.</p>
    /// This field is required.
    pub fn user(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn set_user(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user = input;
        self
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn get_user(&self) -> &::std::option::Option<::std::string::String> {
        &self.user
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    /// This field is required.
    pub fn database(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn set_database(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database = input;
        self
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn get_database(&self) -> &::std::option::Option<::std::string::String> {
        &self.database
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    /// This field is required.
    pub fn schema(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.schema = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn set_schema(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.schema = input;
        self
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn get_schema(&self) -> &::std::option::Option<::std::string::String> {
        &self.schema
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    /// This field is required.
    pub fn table(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.table = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn set_table(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.table = input;
        self
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn get_table(&self) -> &::std::option::Option<::std::string::String> {
        &self.table
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn snowflake_role_configuration(mut self, input: crate::types::SnowflakeRoleConfiguration) -> Self {
        self.snowflake_role_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn set_snowflake_role_configuration(mut self, input: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>) -> Self {
        self.snowflake_role_configuration = input;
        self
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn get_snowflake_role_configuration(&self) -> &::std::option::Option<crate::types::SnowflakeRoleConfiguration> {
        &self.snowflake_role_configuration
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn data_loading_option(mut self, input: crate::types::SnowflakeDataLoadingOption) -> Self {
        self.data_loading_option = ::std::option::Option::Some(input);
        self
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn set_data_loading_option(mut self, input: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>) -> Self {
        self.data_loading_option = input;
        self
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn get_data_loading_option(&self) -> &::std::option::Option<crate::types::SnowflakeDataLoadingOption> {
        &self.data_loading_option
    }
    /// <p>The name of the record metadata column</p>
    pub fn meta_data_column_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.meta_data_column_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the record metadata column</p>
    pub fn set_meta_data_column_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.meta_data_column_name = input;
        self
    }
    /// <p>The name of the record metadata column</p>
    pub fn get_meta_data_column_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.meta_data_column_name
    }
    /// <p>The name of the record content column</p>
    pub fn content_column_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_column_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the record content column</p>
    pub fn set_content_column_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_column_name = input;
        self
    }
    /// <p>The name of the record content column</p>
    pub fn get_content_column_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_column_name
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn snowflake_vpc_configuration(mut self, input: crate::types::SnowflakeVpcConfiguration) -> Self {
        self.snowflake_vpc_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn set_snowflake_vpc_configuration(mut self, input: ::std::option::Option<crate::types::SnowflakeVpcConfiguration>) -> Self {
        self.snowflake_vpc_configuration = input;
        self
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn get_snowflake_vpc_configuration(&self) -> &::std::option::Option<crate::types::SnowflakeVpcConfiguration> {
        &self.snowflake_vpc_configuration
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn cloud_watch_logging_options(mut self, input: crate::types::CloudWatchLoggingOptions) -> Self {
        self.cloud_watch_logging_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn set_cloud_watch_logging_options(mut self, input: ::std::option::Option<crate::types::CloudWatchLoggingOptions>) -> Self {
        self.cloud_watch_logging_options = input;
        self
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn get_cloud_watch_logging_options(&self) -> &::std::option::Option<crate::types::CloudWatchLoggingOptions> {
        &self.cloud_watch_logging_options
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn processing_configuration(mut self, input: crate::types::ProcessingConfiguration) -> Self {
        self.processing_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn set_processing_configuration(mut self, input: ::std::option::Option<crate::types::ProcessingConfiguration>) -> Self {
        self.processing_configuration = input;
        self
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn get_processing_configuration(&self) -> &::std::option::Option<crate::types::ProcessingConfiguration> {
        &self.processing_configuration
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    /// This field is required.
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn retry_options(mut self, input: crate::types::SnowflakeRetryOptions) -> Self {
        self.retry_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn set_retry_options(mut self, input: ::std::option::Option<crate::types::SnowflakeRetryOptions>) -> Self {
        self.retry_options = input;
        self
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn get_retry_options(&self) -> &::std::option::Option<crate::types::SnowflakeRetryOptions> {
        &self.retry_options
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn s3_backup_mode(mut self, input: crate::types::SnowflakeS3BackupMode) -> Self {
        self.s3_backup_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn set_s3_backup_mode(mut self, input: ::std::option::Option<crate::types::SnowflakeS3BackupMode>) -> Self {
        self.s3_backup_mode = input;
        self
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn get_s3_backup_mode(&self) -> &::std::option::Option<crate::types::SnowflakeS3BackupMode> {
        &self.s3_backup_mode
    }
    /// <p>Describes the configuration of a destination in Amazon S3.</p>
    /// This field is required.
    pub fn s3_configuration(mut self, input: crate::types::S3DestinationConfiguration) -> Self {
        self.s3_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the configuration of a destination in Amazon S3.</p>
    pub fn set_s3_configuration(mut self, input: ::std::option::Option<crate::types::S3DestinationConfiguration>) -> Self {
        self.s3_configuration = input;
        self
    }
    /// <p>Describes the configuration of a destination in Amazon S3.</p>
    pub fn get_s3_configuration(&self) -> &::std::option::Option<crate::types::S3DestinationConfiguration> {
        &self.s3_configuration
    }
    /// Consumes the builder and constructs a [`SnowflakeDestinationConfiguration`](crate::types::SnowflakeDestinationConfiguration).
    /// This method will fail if any of the following fields are not set:
    /// - [`account_url`](crate::types::builders::SnowflakeDestinationConfigurationBuilder::account_url)
    /// - [`private_key`](crate::types::builders::SnowflakeDestinationConfigurationBuilder::private_key)
    /// - [`user`](crate::types::builders::SnowflakeDestinationConfigurationBuilder::user)
    /// - [`database`](crate::types::builders::SnowflakeDestinationConfigurationBuilder::database)
    /// - [`schema`](crate::types::builders::SnowflakeDestinationConfigurationBuilder::schema)
    /// - [`table`](crate::types::builders::SnowflakeDestinationConfigurationBuilder::table)
    /// - [`role_arn`](crate::types::builders::SnowflakeDestinationConfigurationBuilder::role_arn)
    pub fn build(self) -> ::std::result::Result<crate::types::SnowflakeDestinationConfiguration, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::SnowflakeDestinationConfiguration {
            account_url: self.account_url.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "account_url",
                    "account_url was not specified but it is required when building SnowflakeDestinationConfiguration",
                )
            })?,
            private_key: self.private_key.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "private_key",
                    "private_key was not specified but it is required when building SnowflakeDestinationConfiguration",
                )
            })?,
            key_passphrase: self.key_passphrase,
            user: self.user.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "user",
                    "user was not specified but it is required when building SnowflakeDestinationConfiguration",
                )
            })?,
            database: self.database.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "database",
                    "database was not specified but it is required when building SnowflakeDestinationConfiguration",
                )
            })?,
            schema: self.schema.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "schema",
                    "schema was not specified but it is required when building SnowflakeDestinationConfiguration",
                )
            })?,
            table: self.table.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "table",
                    "table was not specified but it is required when building SnowflakeDestinationConfiguration",
                )
            })?,
            snowflake_role_configuration: self.snowflake_role_configuration,
            data_loading_option: self.data_loading_option,
            meta_data_column_name: self.meta_data_column_name,
            content_column_name: self.content_column_name,
            snowflake_vpc_configuration: self.snowflake_vpc_configuration,
            cloud_watch_logging_options: self.cloud_watch_logging_options,
            processing_configuration: self.processing_configuration,
            role_arn: self.role_arn.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "role_arn",
                    "role_arn was not specified but it is required when building SnowflakeDestinationConfiguration",
                )
            })?,
            retry_options: self.retry_options,
            s3_backup_mode: self.s3_backup_mode,
            s3_configuration: self.s3_configuration,
        })
    }
}
impl ::std::fmt::Debug for SnowflakeDestinationConfigurationBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SnowflakeDestinationConfigurationBuilder");
        formatter.field("account_url", &"*** Sensitive Data Redacted ***");
        formatter.field("private_key", &"*** Sensitive Data Redacted ***");
        formatter.field("key_passphrase", &"*** Sensitive Data Redacted ***");
        formatter.field("user", &"*** Sensitive Data Redacted ***");
        formatter.field("database", &"*** Sensitive Data Redacted ***");
        formatter.field("schema", &"*** Sensitive Data Redacted ***");
        formatter.field("table", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_role_configuration", &self.snowflake_role_configuration);
        formatter.field("data_loading_option", &self.data_loading_option);
        formatter.field("meta_data_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("content_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_vpc_configuration", &self.snowflake_vpc_configuration);
        formatter.field("cloud_watch_logging_options", &self.cloud_watch_logging_options);
        formatter.field("processing_configuration", &self.processing_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("retry_options", &self.retry_options);
        formatter.field("s3_backup_mode", &self.s3_backup_mode);
        formatter.field("s3_configuration", &self.s3_configuration);
        formatter.finish()
    }
}
