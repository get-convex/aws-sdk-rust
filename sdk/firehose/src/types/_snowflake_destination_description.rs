// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Optional Snowflake destination description</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct SnowflakeDestinationDescription {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub account_url: ::std::option::Option<::std::string::String>,
    /// <p>User login name for the Snowflake account.</p>
    pub user: ::std::option::Option<::std::string::String>,
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub database: ::std::option::Option<::std::string::String>,
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub schema: ::std::option::Option<::std::string::String>,
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub table: ::std::option::Option<::std::string::String>,
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub snowflake_role_configuration: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>,
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub data_loading_option: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>,
    /// <p>The name of the record metadata column</p>
    pub meta_data_column_name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the record content column</p>
    pub content_column_name: ::std::option::Option<::std::string::String>,
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub snowflake_vpc_configuration: ::std::option::Option<crate::types::SnowflakeVpcConfiguration>,
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub cloud_watch_logging_options: ::std::option::Option<crate::types::CloudWatchLoggingOptions>,
    /// <p>Describes a data processing configuration.</p>
    pub processing_configuration: ::std::option::Option<crate::types::ProcessingConfiguration>,
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub role_arn: ::std::option::Option<::std::string::String>,
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub retry_options: ::std::option::Option<crate::types::SnowflakeRetryOptions>,
    /// <p>Choose an S3 backup mode</p>
    pub s3_backup_mode: ::std::option::Option<crate::types::SnowflakeS3BackupMode>,
    /// <p>Describes a destination in Amazon S3.</p>
    pub s3_destination_description: ::std::option::Option<crate::types::S3DestinationDescription>,
}
impl SnowflakeDestinationDescription {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn account_url(&self) -> ::std::option::Option<&str> {
        self.account_url.as_deref()
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn user(&self) -> ::std::option::Option<&str> {
        self.user.as_deref()
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn database(&self) -> ::std::option::Option<&str> {
        self.database.as_deref()
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn schema(&self) -> ::std::option::Option<&str> {
        self.schema.as_deref()
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn table(&self) -> ::std::option::Option<&str> {
        self.table.as_deref()
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn snowflake_role_configuration(&self) -> ::std::option::Option<&crate::types::SnowflakeRoleConfiguration> {
        self.snowflake_role_configuration.as_ref()
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn data_loading_option(&self) -> ::std::option::Option<&crate::types::SnowflakeDataLoadingOption> {
        self.data_loading_option.as_ref()
    }
    /// <p>The name of the record metadata column</p>
    pub fn meta_data_column_name(&self) -> ::std::option::Option<&str> {
        self.meta_data_column_name.as_deref()
    }
    /// <p>The name of the record content column</p>
    pub fn content_column_name(&self) -> ::std::option::Option<&str> {
        self.content_column_name.as_deref()
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn snowflake_vpc_configuration(&self) -> ::std::option::Option<&crate::types::SnowflakeVpcConfiguration> {
        self.snowflake_vpc_configuration.as_ref()
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn cloud_watch_logging_options(&self) -> ::std::option::Option<&crate::types::CloudWatchLoggingOptions> {
        self.cloud_watch_logging_options.as_ref()
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn processing_configuration(&self) -> ::std::option::Option<&crate::types::ProcessingConfiguration> {
        self.processing_configuration.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn role_arn(&self) -> ::std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn retry_options(&self) -> ::std::option::Option<&crate::types::SnowflakeRetryOptions> {
        self.retry_options.as_ref()
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn s3_backup_mode(&self) -> ::std::option::Option<&crate::types::SnowflakeS3BackupMode> {
        self.s3_backup_mode.as_ref()
    }
    /// <p>Describes a destination in Amazon S3.</p>
    pub fn s3_destination_description(&self) -> ::std::option::Option<&crate::types::S3DestinationDescription> {
        self.s3_destination_description.as_ref()
    }
}
impl ::std::fmt::Debug for SnowflakeDestinationDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SnowflakeDestinationDescription");
        formatter.field("account_url", &"*** Sensitive Data Redacted ***");
        formatter.field("user", &"*** Sensitive Data Redacted ***");
        formatter.field("database", &"*** Sensitive Data Redacted ***");
        formatter.field("schema", &"*** Sensitive Data Redacted ***");
        formatter.field("table", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_role_configuration", &self.snowflake_role_configuration);
        formatter.field("data_loading_option", &self.data_loading_option);
        formatter.field("meta_data_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("content_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_vpc_configuration", &self.snowflake_vpc_configuration);
        formatter.field("cloud_watch_logging_options", &self.cloud_watch_logging_options);
        formatter.field("processing_configuration", &self.processing_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("retry_options", &self.retry_options);
        formatter.field("s3_backup_mode", &self.s3_backup_mode);
        formatter.field("s3_destination_description", &self.s3_destination_description);
        formatter.finish()
    }
}
impl SnowflakeDestinationDescription {
    /// Creates a new builder-style object to manufacture [`SnowflakeDestinationDescription`](crate::types::SnowflakeDestinationDescription).
    pub fn builder() -> crate::types::builders::SnowflakeDestinationDescriptionBuilder {
        crate::types::builders::SnowflakeDestinationDescriptionBuilder::default()
    }
}

/// A builder for [`SnowflakeDestinationDescription`](crate::types::SnowflakeDestinationDescription).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct SnowflakeDestinationDescriptionBuilder {
    pub(crate) account_url: ::std::option::Option<::std::string::String>,
    pub(crate) user: ::std::option::Option<::std::string::String>,
    pub(crate) database: ::std::option::Option<::std::string::String>,
    pub(crate) schema: ::std::option::Option<::std::string::String>,
    pub(crate) table: ::std::option::Option<::std::string::String>,
    pub(crate) snowflake_role_configuration: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>,
    pub(crate) data_loading_option: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>,
    pub(crate) meta_data_column_name: ::std::option::Option<::std::string::String>,
    pub(crate) content_column_name: ::std::option::Option<::std::string::String>,
    pub(crate) snowflake_vpc_configuration: ::std::option::Option<crate::types::SnowflakeVpcConfiguration>,
    pub(crate) cloud_watch_logging_options: ::std::option::Option<crate::types::CloudWatchLoggingOptions>,
    pub(crate) processing_configuration: ::std::option::Option<crate::types::ProcessingConfiguration>,
    pub(crate) role_arn: ::std::option::Option<::std::string::String>,
    pub(crate) retry_options: ::std::option::Option<crate::types::SnowflakeRetryOptions>,
    pub(crate) s3_backup_mode: ::std::option::Option<crate::types::SnowflakeS3BackupMode>,
    pub(crate) s3_destination_description: ::std::option::Option<crate::types::S3DestinationDescription>,
}
impl SnowflakeDestinationDescriptionBuilder {
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn account_url(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.account_url = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn set_account_url(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.account_url = input;
        self
    }
    /// <p>URL for accessing your Snowflake account. This URL must include your <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier">account identifier</a>. Note that the protocol (https://) and port number are optional.</p>
    pub fn get_account_url(&self) -> &::std::option::Option<::std::string::String> {
        &self.account_url
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn user(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn set_user(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user = input;
        self
    }
    /// <p>User login name for the Snowflake account.</p>
    pub fn get_user(&self) -> &::std::option::Option<::std::string::String> {
        &self.user
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn database(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.database = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn set_database(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.database = input;
        self
    }
    /// <p>All data in Snowflake is maintained in databases.</p>
    pub fn get_database(&self) -> &::std::option::Option<::std::string::String> {
        &self.database
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn schema(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.schema = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn set_schema(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.schema = input;
        self
    }
    /// <p>Each database consists of one or more schemas, which are logical groupings of database objects, such as tables and views</p>
    pub fn get_schema(&self) -> &::std::option::Option<::std::string::String> {
        &self.schema
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn table(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.table = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn set_table(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.table = input;
        self
    }
    /// <p>All data in Snowflake is stored in database tables, logically structured as collections of columns and rows.</p>
    pub fn get_table(&self) -> &::std::option::Option<::std::string::String> {
        &self.table
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn snowflake_role_configuration(mut self, input: crate::types::SnowflakeRoleConfiguration) -> Self {
        self.snowflake_role_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn set_snowflake_role_configuration(mut self, input: ::std::option::Option<crate::types::SnowflakeRoleConfiguration>) -> Self {
        self.snowflake_role_configuration = input;
        self
    }
    /// <p>Optionally configure a Snowflake role. Otherwise the default user role will be used.</p>
    pub fn get_snowflake_role_configuration(&self) -> &::std::option::Option<crate::types::SnowflakeRoleConfiguration> {
        &self.snowflake_role_configuration
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn data_loading_option(mut self, input: crate::types::SnowflakeDataLoadingOption) -> Self {
        self.data_loading_option = ::std::option::Option::Some(input);
        self
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn set_data_loading_option(mut self, input: ::std::option::Option<crate::types::SnowflakeDataLoadingOption>) -> Self {
        self.data_loading_option = input;
        self
    }
    /// <p>Choose to load JSON keys mapped to table column names or choose to split the JSON payload where content is mapped to a record content column and source metadata is mapped to a record metadata column.</p>
    pub fn get_data_loading_option(&self) -> &::std::option::Option<crate::types::SnowflakeDataLoadingOption> {
        &self.data_loading_option
    }
    /// <p>The name of the record metadata column</p>
    pub fn meta_data_column_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.meta_data_column_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the record metadata column</p>
    pub fn set_meta_data_column_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.meta_data_column_name = input;
        self
    }
    /// <p>The name of the record metadata column</p>
    pub fn get_meta_data_column_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.meta_data_column_name
    }
    /// <p>The name of the record content column</p>
    pub fn content_column_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.content_column_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the record content column</p>
    pub fn set_content_column_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.content_column_name = input;
        self
    }
    /// <p>The name of the record content column</p>
    pub fn get_content_column_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.content_column_name
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn snowflake_vpc_configuration(mut self, input: crate::types::SnowflakeVpcConfiguration) -> Self {
        self.snowflake_vpc_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn set_snowflake_vpc_configuration(mut self, input: ::std::option::Option<crate::types::SnowflakeVpcConfiguration>) -> Self {
        self.snowflake_vpc_configuration = input;
        self
    }
    /// <p>The VPCE ID for Firehose to privately connect with Snowflake. The ID format is com.amazonaws.vpce.[region].vpce-svc-&lt;[id]&gt;. For more information, see <a href="https://docs.snowflake.com/en/user-guide/admin-security-privatelink">Amazon PrivateLink &amp; Snowflake</a></p>
    pub fn get_snowflake_vpc_configuration(&self) -> &::std::option::Option<crate::types::SnowflakeVpcConfiguration> {
        &self.snowflake_vpc_configuration
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn cloud_watch_logging_options(mut self, input: crate::types::CloudWatchLoggingOptions) -> Self {
        self.cloud_watch_logging_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn set_cloud_watch_logging_options(mut self, input: ::std::option::Option<crate::types::CloudWatchLoggingOptions>) -> Self {
        self.cloud_watch_logging_options = input;
        self
    }
    /// <p>Describes the Amazon CloudWatch logging options for your delivery stream.</p>
    pub fn get_cloud_watch_logging_options(&self) -> &::std::option::Option<crate::types::CloudWatchLoggingOptions> {
        &self.cloud_watch_logging_options
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn processing_configuration(mut self, input: crate::types::ProcessingConfiguration) -> Self {
        self.processing_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn set_processing_configuration(mut self, input: ::std::option::Option<crate::types::ProcessingConfiguration>) -> Self {
        self.processing_configuration = input;
        self
    }
    /// <p>Describes a data processing configuration.</p>
    pub fn get_processing_configuration(&self) -> &::std::option::Option<crate::types::ProcessingConfiguration> {
        &self.processing_configuration
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.role_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn set_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.role_arn = input;
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the Snowflake role</p>
    pub fn get_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.role_arn
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn retry_options(mut self, input: crate::types::SnowflakeRetryOptions) -> Self {
        self.retry_options = ::std::option::Option::Some(input);
        self
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn set_retry_options(mut self, input: ::std::option::Option<crate::types::SnowflakeRetryOptions>) -> Self {
        self.retry_options = input;
        self
    }
    /// <p>The time period where Kinesis Data Firehose will retry sending data to the chosen HTTP endpoint.</p>
    pub fn get_retry_options(&self) -> &::std::option::Option<crate::types::SnowflakeRetryOptions> {
        &self.retry_options
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn s3_backup_mode(mut self, input: crate::types::SnowflakeS3BackupMode) -> Self {
        self.s3_backup_mode = ::std::option::Option::Some(input);
        self
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn set_s3_backup_mode(mut self, input: ::std::option::Option<crate::types::SnowflakeS3BackupMode>) -> Self {
        self.s3_backup_mode = input;
        self
    }
    /// <p>Choose an S3 backup mode</p>
    pub fn get_s3_backup_mode(&self) -> &::std::option::Option<crate::types::SnowflakeS3BackupMode> {
        &self.s3_backup_mode
    }
    /// <p>Describes a destination in Amazon S3.</p>
    pub fn s3_destination_description(mut self, input: crate::types::S3DestinationDescription) -> Self {
        self.s3_destination_description = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes a destination in Amazon S3.</p>
    pub fn set_s3_destination_description(mut self, input: ::std::option::Option<crate::types::S3DestinationDescription>) -> Self {
        self.s3_destination_description = input;
        self
    }
    /// <p>Describes a destination in Amazon S3.</p>
    pub fn get_s3_destination_description(&self) -> &::std::option::Option<crate::types::S3DestinationDescription> {
        &self.s3_destination_description
    }
    /// Consumes the builder and constructs a [`SnowflakeDestinationDescription`](crate::types::SnowflakeDestinationDescription).
    pub fn build(self) -> crate::types::SnowflakeDestinationDescription {
        crate::types::SnowflakeDestinationDescription {
            account_url: self.account_url,
            user: self.user,
            database: self.database,
            schema: self.schema,
            table: self.table,
            snowflake_role_configuration: self.snowflake_role_configuration,
            data_loading_option: self.data_loading_option,
            meta_data_column_name: self.meta_data_column_name,
            content_column_name: self.content_column_name,
            snowflake_vpc_configuration: self.snowflake_vpc_configuration,
            cloud_watch_logging_options: self.cloud_watch_logging_options,
            processing_configuration: self.processing_configuration,
            role_arn: self.role_arn,
            retry_options: self.retry_options,
            s3_backup_mode: self.s3_backup_mode,
            s3_destination_description: self.s3_destination_description,
        }
    }
}
impl ::std::fmt::Debug for SnowflakeDestinationDescriptionBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("SnowflakeDestinationDescriptionBuilder");
        formatter.field("account_url", &"*** Sensitive Data Redacted ***");
        formatter.field("user", &"*** Sensitive Data Redacted ***");
        formatter.field("database", &"*** Sensitive Data Redacted ***");
        formatter.field("schema", &"*** Sensitive Data Redacted ***");
        formatter.field("table", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_role_configuration", &self.snowflake_role_configuration);
        formatter.field("data_loading_option", &self.data_loading_option);
        formatter.field("meta_data_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("content_column_name", &"*** Sensitive Data Redacted ***");
        formatter.field("snowflake_vpc_configuration", &self.snowflake_vpc_configuration);
        formatter.field("cloud_watch_logging_options", &self.cloud_watch_logging_options);
        formatter.field("processing_configuration", &self.processing_configuration);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("retry_options", &self.retry_options);
        formatter.field("s3_backup_mode", &self.s3_backup_mode);
        formatter.field("s3_destination_description", &self.s3_destination_description);
        formatter.finish()
    }
}
