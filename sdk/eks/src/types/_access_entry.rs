// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>An access entry allows an IAM principal (user or role) to access your cluster. Access entries can replace the need to maintain the <code>aws-auth</code> <code>ConfigMap</code> for authentication. For more information about access entries, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html">Access entries</a> in the <i>Amazon EKS User Guide</i>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct AccessEntry {
    /// <p>The name of your cluster.</p>
    pub cluster_name: ::std::option::Option<::std::string::String>,
    /// <p>The ARN of the IAM principal for the access entry. If you ever delete the IAM principal with this ARN, the access entry isn't automatically deleted. We recommend that you delete the access entry with an ARN for an IAM principal that you delete. If you don't delete the access entry and ever recreate the IAM principal, even if it has the same ARN, the access entry won't work. This is because even though the ARN is the same for the recreated IAM principal, the <code>roleID</code> or <code>userID</code> (you can see this with the Security Token Service <code>GetCallerIdentity</code> API) is different for the recreated IAM principal than it was for the original IAM principal. Even though you don't see the IAM principal's <code>roleID</code> or <code>userID</code> for an access entry, Amazon EKS stores it with the access entry.</p>
    pub principal_arn: ::std::option::Option<::std::string::String>,
    /// <p>A <code>name</code> that you've specified in a Kubernetes <code>RoleBinding</code> or <code>ClusterRoleBinding</code> object so that Kubernetes authorizes the <code>principalARN</code> access to cluster objects.</p>
    pub kubernetes_groups: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The ARN of the access entry.</p>
    pub access_entry_arn: ::std::option::Option<::std::string::String>,
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The <code>name</code> of a user that can authenticate to your cluster.</p>
    pub username: ::std::option::Option<::std::string::String>,
    /// <p>The type of the access entry.</p>
    pub r#type: ::std::option::Option<::std::string::String>,
}
impl AccessEntry {
    /// <p>The name of your cluster.</p>
    pub fn cluster_name(&self) -> ::std::option::Option<&str> {
        self.cluster_name.as_deref()
    }
    /// <p>The ARN of the IAM principal for the access entry. If you ever delete the IAM principal with this ARN, the access entry isn't automatically deleted. We recommend that you delete the access entry with an ARN for an IAM principal that you delete. If you don't delete the access entry and ever recreate the IAM principal, even if it has the same ARN, the access entry won't work. This is because even though the ARN is the same for the recreated IAM principal, the <code>roleID</code> or <code>userID</code> (you can see this with the Security Token Service <code>GetCallerIdentity</code> API) is different for the recreated IAM principal than it was for the original IAM principal. Even though you don't see the IAM principal's <code>roleID</code> or <code>userID</code> for an access entry, Amazon EKS stores it with the access entry.</p>
    pub fn principal_arn(&self) -> ::std::option::Option<&str> {
        self.principal_arn.as_deref()
    }
    /// <p>A <code>name</code> that you've specified in a Kubernetes <code>RoleBinding</code> or <code>ClusterRoleBinding</code> object so that Kubernetes authorizes the <code>principalARN</code> access to cluster objects.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.kubernetes_groups.is_none()`.
    pub fn kubernetes_groups(&self) -> &[::std::string::String] {
        self.kubernetes_groups.as_deref().unwrap_or_default()
    }
    /// <p>The ARN of the access entry.</p>
    pub fn access_entry_arn(&self) -> ::std::option::Option<&str> {
        self.access_entry_arn.as_deref()
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn created_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn modified_at(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.modified_at.as_ref()
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The <code>name</code> of a user that can authenticate to your cluster.</p>
    pub fn username(&self) -> ::std::option::Option<&str> {
        self.username.as_deref()
    }
    /// <p>The type of the access entry.</p>
    pub fn r#type(&self) -> ::std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl AccessEntry {
    /// Creates a new builder-style object to manufacture [`AccessEntry`](crate::types::AccessEntry).
    pub fn builder() -> crate::types::builders::AccessEntryBuilder {
        crate::types::builders::AccessEntryBuilder::default()
    }
}

/// A builder for [`AccessEntry`](crate::types::AccessEntry).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct AccessEntryBuilder {
    pub(crate) cluster_name: ::std::option::Option<::std::string::String>,
    pub(crate) principal_arn: ::std::option::Option<::std::string::String>,
    pub(crate) kubernetes_groups: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) access_entry_arn: ::std::option::Option<::std::string::String>,
    pub(crate) created_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) modified_at: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) username: ::std::option::Option<::std::string::String>,
    pub(crate) r#type: ::std::option::Option<::std::string::String>,
}
impl AccessEntryBuilder {
    /// <p>The name of your cluster.</p>
    pub fn cluster_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.cluster_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of your cluster.</p>
    pub fn set_cluster_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.cluster_name = input;
        self
    }
    /// <p>The name of your cluster.</p>
    pub fn get_cluster_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.cluster_name
    }
    /// <p>The ARN of the IAM principal for the access entry. If you ever delete the IAM principal with this ARN, the access entry isn't automatically deleted. We recommend that you delete the access entry with an ARN for an IAM principal that you delete. If you don't delete the access entry and ever recreate the IAM principal, even if it has the same ARN, the access entry won't work. This is because even though the ARN is the same for the recreated IAM principal, the <code>roleID</code> or <code>userID</code> (you can see this with the Security Token Service <code>GetCallerIdentity</code> API) is different for the recreated IAM principal than it was for the original IAM principal. Even though you don't see the IAM principal's <code>roleID</code> or <code>userID</code> for an access entry, Amazon EKS stores it with the access entry.</p>
    pub fn principal_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.principal_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the IAM principal for the access entry. If you ever delete the IAM principal with this ARN, the access entry isn't automatically deleted. We recommend that you delete the access entry with an ARN for an IAM principal that you delete. If you don't delete the access entry and ever recreate the IAM principal, even if it has the same ARN, the access entry won't work. This is because even though the ARN is the same for the recreated IAM principal, the <code>roleID</code> or <code>userID</code> (you can see this with the Security Token Service <code>GetCallerIdentity</code> API) is different for the recreated IAM principal than it was for the original IAM principal. Even though you don't see the IAM principal's <code>roleID</code> or <code>userID</code> for an access entry, Amazon EKS stores it with the access entry.</p>
    pub fn set_principal_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.principal_arn = input;
        self
    }
    /// <p>The ARN of the IAM principal for the access entry. If you ever delete the IAM principal with this ARN, the access entry isn't automatically deleted. We recommend that you delete the access entry with an ARN for an IAM principal that you delete. If you don't delete the access entry and ever recreate the IAM principal, even if it has the same ARN, the access entry won't work. This is because even though the ARN is the same for the recreated IAM principal, the <code>roleID</code> or <code>userID</code> (you can see this with the Security Token Service <code>GetCallerIdentity</code> API) is different for the recreated IAM principal than it was for the original IAM principal. Even though you don't see the IAM principal's <code>roleID</code> or <code>userID</code> for an access entry, Amazon EKS stores it with the access entry.</p>
    pub fn get_principal_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.principal_arn
    }
    /// Appends an item to `kubernetes_groups`.
    ///
    /// To override the contents of this collection use [`set_kubernetes_groups`](Self::set_kubernetes_groups).
    ///
    /// <p>A <code>name</code> that you've specified in a Kubernetes <code>RoleBinding</code> or <code>ClusterRoleBinding</code> object so that Kubernetes authorizes the <code>principalARN</code> access to cluster objects.</p>
    pub fn kubernetes_groups(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.kubernetes_groups.unwrap_or_default();
        v.push(input.into());
        self.kubernetes_groups = ::std::option::Option::Some(v);
        self
    }
    /// <p>A <code>name</code> that you've specified in a Kubernetes <code>RoleBinding</code> or <code>ClusterRoleBinding</code> object so that Kubernetes authorizes the <code>principalARN</code> access to cluster objects.</p>
    pub fn set_kubernetes_groups(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.kubernetes_groups = input;
        self
    }
    /// <p>A <code>name</code> that you've specified in a Kubernetes <code>RoleBinding</code> or <code>ClusterRoleBinding</code> object so that Kubernetes authorizes the <code>principalARN</code> access to cluster objects.</p>
    pub fn get_kubernetes_groups(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.kubernetes_groups
    }
    /// <p>The ARN of the access entry.</p>
    pub fn access_entry_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.access_entry_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN of the access entry.</p>
    pub fn set_access_entry_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.access_entry_arn = input;
        self
    }
    /// <p>The ARN of the access entry.</p>
    pub fn get_access_entry_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.access_entry_arn
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn created_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.created_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn set_created_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.created_at = input;
        self
    }
    /// <p>The Unix epoch timestamp at object creation.</p>
    pub fn get_created_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.created_at
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn modified_at(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.modified_at = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn set_modified_at(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.modified_at = input;
        self
    }
    /// <p>The Unix epoch timestamp for the last modification to the object.</p>
    pub fn get_modified_at(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.modified_at
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The <code>name</code> of a user that can authenticate to your cluster.</p>
    pub fn username(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.username = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>name</code> of a user that can authenticate to your cluster.</p>
    pub fn set_username(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.username = input;
        self
    }
    /// <p>The <code>name</code> of a user that can authenticate to your cluster.</p>
    pub fn get_username(&self) -> &::std::option::Option<::std::string::String> {
        &self.username
    }
    /// <p>The type of the access entry.</p>
    pub fn r#type(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.r#type = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The type of the access entry.</p>
    pub fn set_type(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The type of the access entry.</p>
    pub fn get_type(&self) -> &::std::option::Option<::std::string::String> {
        &self.r#type
    }
    /// Consumes the builder and constructs a [`AccessEntry`](crate::types::AccessEntry).
    pub fn build(self) -> crate::types::AccessEntry {
        crate::types::AccessEntry {
            cluster_name: self.cluster_name,
            principal_arn: self.principal_arn,
            kubernetes_groups: self.kubernetes_groups,
            access_entry_arn: self.access_entry_arn,
            created_at: self.created_at,
            modified_at: self.modified_at,
            tags: self.tags,
            username: self.username,
            r#type: self.r#type,
        }
    }
}
