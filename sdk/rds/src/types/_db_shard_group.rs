// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct DbShardGroup {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub db_shard_group_resource_id: ::std::option::Option<::std::string::String>,
    /// <p>The name of the DB shard group.</p>
    pub db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub db_cluster_identifier: ::std::option::Option<::std::string::String>,
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub max_acu: ::std::option::Option<f64>,
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub compute_redundancy: ::std::option::Option<i32>,
    /// <p>The status of the DB shard group.</p>
    pub status: ::std::option::Option<::std::string::String>,
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub publicly_accessible: ::std::option::Option<bool>,
    /// <p>The connection endpoint for the DB shard group.</p>
    pub endpoint: ::std::option::Option<::std::string::String>,
}
impl DbShardGroup {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn db_shard_group_resource_id(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_resource_id.as_deref()
    }
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(&self) -> ::std::option::Option<&str> {
        self.db_shard_group_identifier.as_deref()
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(&self) -> ::std::option::Option<&str> {
        self.db_cluster_identifier.as_deref()
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(&self) -> ::std::option::Option<f64> {
        self.max_acu
    }
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub fn compute_redundancy(&self) -> ::std::option::Option<i32> {
        self.compute_redundancy
    }
    /// <p>The status of the DB shard group.</p>
    pub fn status(&self) -> ::std::option::Option<&str> {
        self.status.as_deref()
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn publicly_accessible(&self) -> ::std::option::Option<bool> {
        self.publicly_accessible
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn endpoint(&self) -> ::std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
impl DbShardGroup {
    /// Creates a new builder-style object to manufacture [`DbShardGroup`](crate::types::DbShardGroup).
    pub fn builder() -> crate::types::builders::DbShardGroupBuilder {
        crate::types::builders::DbShardGroupBuilder::default()
    }
}

/// A builder for [`DbShardGroup`](crate::types::DbShardGroup).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct DbShardGroupBuilder {
    pub(crate) db_shard_group_resource_id: ::std::option::Option<::std::string::String>,
    pub(crate) db_shard_group_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) db_cluster_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) max_acu: ::std::option::Option<f64>,
    pub(crate) compute_redundancy: ::std::option::Option<i32>,
    pub(crate) status: ::std::option::Option<::std::string::String>,
    pub(crate) publicly_accessible: ::std::option::Option<bool>,
    pub(crate) endpoint: ::std::option::Option<::std::string::String>,
}
impl DbShardGroupBuilder {
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn db_shard_group_resource_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_resource_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn set_db_shard_group_resource_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_resource_id = input;
        self
    }
    /// <p>The Amazon Web Services Region-unique, immutable identifier for the DB shard group.</p>
    pub fn get_db_shard_group_resource_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_resource_id
    }
    /// <p>The name of the DB shard group.</p>
    pub fn db_shard_group_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_shard_group_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn set_db_shard_group_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_shard_group_identifier = input;
        self
    }
    /// <p>The name of the DB shard group.</p>
    pub fn get_db_shard_group_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_shard_group_identifier
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn db_cluster_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.db_cluster_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn set_db_cluster_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.db_cluster_identifier = input;
        self
    }
    /// <p>The name of the primary DB cluster for the DB shard group.</p>
    pub fn get_db_cluster_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.db_cluster_identifier
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn max_acu(mut self, input: f64) -> Self {
        self.max_acu = ::std::option::Option::Some(input);
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn set_max_acu(mut self, input: ::std::option::Option<f64>) -> Self {
        self.max_acu = input;
        self
    }
    /// <p>The maximum capacity of the DB shard group in Aurora capacity units (ACUs).</p>
    pub fn get_max_acu(&self) -> &::std::option::Option<f64> {
        &self.max_acu
    }
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub fn compute_redundancy(mut self, input: i32) -> Self {
        self.compute_redundancy = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub fn set_compute_redundancy(mut self, input: ::std::option::Option<i32>) -> Self {
        self.compute_redundancy = input;
        self
    }
    /// <p>Specifies whether to create standby instances for the DB shard group. Valid values are the following:</p>
    /// <ul>
    /// <li>
    /// <p>0 - Creates a single, primary DB instance for each physical shard. This is the default value, and the only one supported for the preview.</p></li>
    /// <li>
    /// <p>1 - Creates a primary DB instance and a standby instance in a different Availability Zone (AZ) for each physical shard.</p></li>
    /// <li>
    /// <p>2 - Creates a primary DB instance and two standby instances in different AZs for each physical shard.</p></li>
    /// </ul>
    pub fn get_compute_redundancy(&self) -> &::std::option::Option<i32> {
        &self.compute_redundancy
    }
    /// <p>The status of the DB shard group.</p>
    pub fn status(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.status = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The status of the DB shard group.</p>
    pub fn set_status(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.status = input;
        self
    }
    /// <p>The status of the DB shard group.</p>
    pub fn get_status(&self) -> &::std::option::Option<::std::string::String> {
        &self.status
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn publicly_accessible(mut self, input: bool) -> Self {
        self.publicly_accessible = ::std::option::Option::Some(input);
        self
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn set_publicly_accessible(mut self, input: ::std::option::Option<bool>) -> Self {
        self.publicly_accessible = input;
        self
    }
    /// <p>Indicates whether the DB shard group is publicly accessible.</p>
    /// <p>When the DB shard group is publicly accessible, its Domain Name System (DNS) endpoint resolves to the private IP address from within the DB shard group's virtual private cloud (VPC). It resolves to the public IP address from outside of the DB shard group's VPC. Access to the DB shard group is ultimately controlled by the security group it uses. That public access isn't permitted if the security group assigned to the DB shard group doesn't permit it.</p>
    /// <p>When the DB shard group isn't publicly accessible, it is an internal DB shard group with a DNS name that resolves to a private IP address.</p>
    /// <p>For more information, see <code>CreateDBShardGroup</code>.</p>
    /// <p>This setting is only for Aurora Limitless Database.</p>
    pub fn get_publicly_accessible(&self) -> &::std::option::Option<bool> {
        &self.publicly_accessible
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn endpoint(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.endpoint = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn set_endpoint(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.endpoint = input;
        self
    }
    /// <p>The connection endpoint for the DB shard group.</p>
    pub fn get_endpoint(&self) -> &::std::option::Option<::std::string::String> {
        &self.endpoint
    }
    /// Consumes the builder and constructs a [`DbShardGroup`](crate::types::DbShardGroup).
    pub fn build(self) -> crate::types::DbShardGroup {
        crate::types::DbShardGroup {
            db_shard_group_resource_id: self.db_shard_group_resource_id,
            db_shard_group_identifier: self.db_shard_group_identifier,
            db_cluster_identifier: self.db_cluster_identifier,
            max_acu: self.max_acu,
            compute_redundancy: self.compute_redundancy,
            status: self.status,
            publicly_accessible: self.publicly_accessible,
            endpoint: self.endpoint,
        }
    }
}
