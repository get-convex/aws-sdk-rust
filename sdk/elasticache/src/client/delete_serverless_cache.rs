// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
impl super::Client {
    /// Constructs a fluent builder for the [`DeleteServerlessCache`](crate::operation::delete_serverless_cache::builders::DeleteServerlessCacheFluentBuilder) operation.
    ///
    /// - The fluent builder is configurable:
    ///   - [`serverless_cache_name(impl Into<String>)`](crate::operation::delete_serverless_cache::builders::DeleteServerlessCacheFluentBuilder::serverless_cache_name) / [`set_serverless_cache_name(Option<String>)`](crate::operation::delete_serverless_cache::builders::DeleteServerlessCacheFluentBuilder::set_serverless_cache_name):<br>required: **true**<br><p>The identifier of the serverless cache to be deleted.</p><br>
    ///   - [`final_snapshot_name(impl Into<String>)`](crate::operation::delete_serverless_cache::builders::DeleteServerlessCacheFluentBuilder::final_snapshot_name) / [`set_final_snapshot_name(Option<String>)`](crate::operation::delete_serverless_cache::builders::DeleteServerlessCacheFluentBuilder::set_final_snapshot_name):<br>required: **false**<br><p>Name of the final snapshot to be taken before the serverless cache is deleted. Available for Redis only. Default: NULL, i.e. a final snapshot is not taken.</p><br>
    /// - On success, responds with [`DeleteServerlessCacheOutput`](crate::operation::delete_serverless_cache::DeleteServerlessCacheOutput) with field(s):
    ///   - [`serverless_cache(Option<ServerlessCache>)`](crate::operation::delete_serverless_cache::DeleteServerlessCacheOutput::serverless_cache): <p>Provides the details of the specified serverless cache that is about to be deleted.</p>
    /// - On failure, responds with [`SdkError<DeleteServerlessCacheError>`](crate::operation::delete_serverless_cache::DeleteServerlessCacheError)
    pub fn delete_serverless_cache(&self) -> crate::operation::delete_serverless_cache::builders::DeleteServerlessCacheFluentBuilder {
        crate::operation::delete_serverless_cache::builders::DeleteServerlessCacheFluentBuilder::new(self.handle.clone())
    }
}
