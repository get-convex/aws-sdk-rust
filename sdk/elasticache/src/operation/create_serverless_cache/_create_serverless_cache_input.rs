// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CreateServerlessCacheInput {
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    pub serverless_cache_name: ::std::option::Option<::std::string::String>,
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    pub engine: ::std::option::Option<::std::string::String>,
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub major_engine_version: ::std::option::Option<::std::string::String>,
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub cache_usage_limits: ::std::option::Option<crate::types::CacheUsageLimits>,
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub kms_key_id: ::std::option::Option<::std::string::String>,
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    pub security_group_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    pub snapshot_arns_to_restore: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    pub tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub user_group_id: ::std::option::Option<::std::string::String>,
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    pub subnet_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub snapshot_retention_limit: ::std::option::Option<i32>,
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub daily_snapshot_time: ::std::option::Option<::std::string::String>,
}
impl CreateServerlessCacheInput {
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    pub fn serverless_cache_name(&self) -> ::std::option::Option<&str> {
        self.serverless_cache_name.as_deref()
    }
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    pub fn engine(&self) -> ::std::option::Option<&str> {
        self.engine.as_deref()
    }
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub fn major_engine_version(&self) -> ::std::option::Option<&str> {
        self.major_engine_version.as_deref()
    }
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub fn cache_usage_limits(&self) -> ::std::option::Option<&crate::types::CacheUsageLimits> {
        self.cache_usage_limits.as_ref()
    }
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub fn kms_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_key_id.as_deref()
    }
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.security_group_ids.is_none()`.
    pub fn security_group_ids(&self) -> &[::std::string::String] {
        self.security_group_ids.as_deref().unwrap_or_default()
    }
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.snapshot_arns_to_restore.is_none()`.
    pub fn snapshot_arns_to_restore(&self) -> &[::std::string::String] {
        self.snapshot_arns_to_restore.as_deref().unwrap_or_default()
    }
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.tags.is_none()`.
    pub fn tags(&self) -> &[crate::types::Tag] {
        self.tags.as_deref().unwrap_or_default()
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn user_group_id(&self) -> ::std::option::Option<&str> {
        self.user_group_id.as_deref()
    }
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.subnet_ids.is_none()`.
    pub fn subnet_ids(&self) -> &[::std::string::String] {
        self.subnet_ids.as_deref().unwrap_or_default()
    }
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub fn snapshot_retention_limit(&self) -> ::std::option::Option<i32> {
        self.snapshot_retention_limit
    }
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub fn daily_snapshot_time(&self) -> ::std::option::Option<&str> {
        self.daily_snapshot_time.as_deref()
    }
}
impl CreateServerlessCacheInput {
    /// Creates a new builder-style object to manufacture [`CreateServerlessCacheInput`](crate::operation::create_serverless_cache::CreateServerlessCacheInput).
    pub fn builder() -> crate::operation::create_serverless_cache::builders::CreateServerlessCacheInputBuilder {
        crate::operation::create_serverless_cache::builders::CreateServerlessCacheInputBuilder::default()
    }
}

/// A builder for [`CreateServerlessCacheInput`](crate::operation::create_serverless_cache::CreateServerlessCacheInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CreateServerlessCacheInputBuilder {
    pub(crate) serverless_cache_name: ::std::option::Option<::std::string::String>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) engine: ::std::option::Option<::std::string::String>,
    pub(crate) major_engine_version: ::std::option::Option<::std::string::String>,
    pub(crate) cache_usage_limits: ::std::option::Option<crate::types::CacheUsageLimits>,
    pub(crate) kms_key_id: ::std::option::Option<::std::string::String>,
    pub(crate) security_group_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) snapshot_arns_to_restore: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) tags: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>,
    pub(crate) user_group_id: ::std::option::Option<::std::string::String>,
    pub(crate) subnet_ids: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    pub(crate) snapshot_retention_limit: ::std::option::Option<i32>,
    pub(crate) daily_snapshot_time: ::std::option::Option<::std::string::String>,
}
impl CreateServerlessCacheInputBuilder {
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    /// This field is required.
    pub fn serverless_cache_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.serverless_cache_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    pub fn set_serverless_cache_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.serverless_cache_name = input;
        self
    }
    /// <p>User-provided identifier for the serverless cache. This parameter is stored as a lowercase string.</p>
    pub fn get_serverless_cache_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.serverless_cache_name
    }
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>User-provided description for the serverless cache. The default is NULL, i.e. if no description is provided then an empty string will be returned. The maximum length is 255 characters.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    /// This field is required.
    pub fn engine(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.engine = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    pub fn set_engine(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.engine = input;
        self
    }
    /// <p>The name of the cache engine to be used for creating the serverless cache.</p>
    pub fn get_engine(&self) -> &::std::option::Option<::std::string::String> {
        &self.engine
    }
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub fn major_engine_version(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.major_engine_version = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub fn set_major_engine_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.major_engine_version = input;
        self
    }
    /// <p>The version of the cache engine that will be used to create the serverless cache.</p>
    pub fn get_major_engine_version(&self) -> &::std::option::Option<::std::string::String> {
        &self.major_engine_version
    }
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub fn cache_usage_limits(mut self, input: crate::types::CacheUsageLimits) -> Self {
        self.cache_usage_limits = ::std::option::Option::Some(input);
        self
    }
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub fn set_cache_usage_limits(mut self, input: ::std::option::Option<crate::types::CacheUsageLimits>) -> Self {
        self.cache_usage_limits = input;
        self
    }
    /// <p>Sets the cache usage limits for storage and ElastiCache Processing Units for the cache.</p>
    pub fn get_cache_usage_limits(&self) -> &::std::option::Option<crate::types::CacheUsageLimits> {
        &self.cache_usage_limits
    }
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub fn kms_key_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub fn set_kms_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_id = input;
        self
    }
    /// <p>ARN of the customer managed key for encrypting the data at rest. If no KMS key is provided, a default service key is used.</p>
    pub fn get_kms_key_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_id
    }
    /// Appends an item to `security_group_ids`.
    ///
    /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
    ///
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    pub fn security_group_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.security_group_ids.unwrap_or_default();
        v.push(input.into());
        self.security_group_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    pub fn set_security_group_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.security_group_ids = input;
        self
    }
    /// <p>A list of the one or more VPC security groups to be associated with the serverless cache. The security group will authorize traffic access for the VPC end-point (private-link). If no other information is given this will be the VPC’s Default Security Group that is associated with the cluster VPC end-point.</p>
    pub fn get_security_group_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.security_group_ids
    }
    /// Appends an item to `snapshot_arns_to_restore`.
    ///
    /// To override the contents of this collection use [`set_snapshot_arns_to_restore`](Self::set_snapshot_arns_to_restore).
    ///
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    pub fn snapshot_arns_to_restore(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.snapshot_arns_to_restore.unwrap_or_default();
        v.push(input.into());
        self.snapshot_arns_to_restore = ::std::option::Option::Some(v);
        self
    }
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    pub fn set_snapshot_arns_to_restore(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.snapshot_arns_to_restore = input;
        self
    }
    /// <p>The ARN(s) of the snapshot that the new serverless cache will be created from. Available for Redis only.</p>
    pub fn get_snapshot_arns_to_restore(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.snapshot_arns_to_restore
    }
    /// Appends an item to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    pub fn tags(mut self, input: crate::types::Tag) -> Self {
        let mut v = self.tags.unwrap_or_default();
        v.push(input);
        self.tags = ::std::option::Option::Some(v);
        self
    }
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Tag>>) -> Self {
        self.tags = input;
        self
    }
    /// <p>The list of tags (key, value) pairs to be added to the serverless cache resource. Default is NULL.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Tag>> {
        &self.tags
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn user_group_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user_group_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn set_user_group_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user_group_id = input;
        self
    }
    /// <p>The identifier of the UserGroup to be associated with the serverless cache. Available for Redis only. Default is NULL.</p>
    pub fn get_user_group_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.user_group_id
    }
    /// Appends an item to `subnet_ids`.
    ///
    /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
    ///
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    pub fn subnet_ids(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut v = self.subnet_ids.unwrap_or_default();
        v.push(input.into());
        self.subnet_ids = ::std::option::Option::Some(v);
        self
    }
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    pub fn set_subnet_ids(mut self, input: ::std::option::Option<::std::vec::Vec<::std::string::String>>) -> Self {
        self.subnet_ids = input;
        self
    }
    /// <p>A list of the identifiers of the subnets where the VPC endpoint for the serverless cache will be deployed. All the subnetIds must belong to the same VPC.</p>
    pub fn get_subnet_ids(&self) -> &::std::option::Option<::std::vec::Vec<::std::string::String>> {
        &self.subnet_ids
    }
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub fn snapshot_retention_limit(mut self, input: i32) -> Self {
        self.snapshot_retention_limit = ::std::option::Option::Some(input);
        self
    }
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub fn set_snapshot_retention_limit(mut self, input: ::std::option::Option<i32>) -> Self {
        self.snapshot_retention_limit = input;
        self
    }
    /// <p>The number of snapshots that will be retained for the serverless cache that is being created. As new snapshots beyond this limit are added, the oldest snapshots will be deleted on a rolling basis. Available for Redis only.</p>
    pub fn get_snapshot_retention_limit(&self) -> &::std::option::Option<i32> {
        &self.snapshot_retention_limit
    }
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub fn daily_snapshot_time(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.daily_snapshot_time = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub fn set_daily_snapshot_time(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.daily_snapshot_time = input;
        self
    }
    /// <p>The daily time that snapshots will be created from the new serverless cache. By default this number is populated with 0, i.e. no snapshots will be created on an automatic daily basis. Available for Redis only.</p>
    pub fn get_daily_snapshot_time(&self) -> &::std::option::Option<::std::string::String> {
        &self.daily_snapshot_time
    }
    /// Consumes the builder and constructs a [`CreateServerlessCacheInput`](crate::operation::create_serverless_cache::CreateServerlessCacheInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::create_serverless_cache::CreateServerlessCacheInput, ::aws_smithy_types::error::operation::BuildError>
    {
        ::std::result::Result::Ok(crate::operation::create_serverless_cache::CreateServerlessCacheInput {
            serverless_cache_name: self.serverless_cache_name,
            description: self.description,
            engine: self.engine,
            major_engine_version: self.major_engine_version,
            cache_usage_limits: self.cache_usage_limits,
            kms_key_id: self.kms_key_id,
            security_group_ids: self.security_group_ids,
            snapshot_arns_to_restore: self.snapshot_arns_to_restore,
            tags: self.tags,
            user_group_id: self.user_group_id,
            subnet_ids: self.subnet_ids,
            snapshot_retention_limit: self.snapshot_retention_limit,
            daily_snapshot_time: self.daily_snapshot_time,
        })
    }
}
