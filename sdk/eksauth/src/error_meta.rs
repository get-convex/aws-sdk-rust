// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum Error {
    /// <p>You don't have permissions to perform the requested operation. The IAM principal making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html">Access management</a> in the <i>IAM User Guide</i>.</p>
    AccessDeniedException(crate::types::error::AccessDeniedException),
    /// <p>The specified Kubernetes service account token is expired.</p>
    ExpiredTokenException(crate::types::error::ExpiredTokenException),
    /// <p>These errors are usually caused by a server-side issue.</p>
    InternalServerException(crate::types::error::InternalServerException),
    /// <p>The specified parameter is invalid. Review the available parameters for the API request.</p>
    InvalidParameterException(crate::types::error::InvalidParameterException),
    /// <p>This exception is thrown if the request contains a semantic error. The precise meaning will depend on the API, and will be documented in the error message.</p>
    InvalidRequestException(crate::types::error::InvalidRequestException),
    /// <p>The specified Kubernetes service account token is invalid.</p>
    InvalidTokenException(crate::types::error::InvalidTokenException),
    /// <p>The specified resource could not be found.</p>
    ResourceNotFoundException(crate::types::error::ResourceNotFoundException),
    /// <p>The service is unavailable. Back off and retry the operation.</p>
    ServiceUnavailableException(crate::types::error::ServiceUnavailableException),
    /// <p>The request was denied because your request rate is too high. Reduce the frequency of requests.</p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-Error) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl ::std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessDeniedException(inner) => inner.fmt(f),
            Error::ExpiredTokenException(inner) => inner.fmt(f),
            Error::InternalServerException(inner) => inner.fmt(f),
            Error::InvalidParameterException(inner) => inner.fmt(f),
            Error::InvalidRequestException(inner) => inner.fmt(f),
            Error::InvalidTokenException(inner) => inner.fmt(f),
            Error::ResourceNotFoundException(inner) => inner.fmt(f),
            Error::ServiceUnavailableException(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::Unhandled(_) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl From<::aws_smithy_types::error::operation::BuildError> for Error {
    fn from(value: ::aws_smithy_types::error::operation::BuildError) -> Self {
        Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: value.into(),
            meta: ::std::default::Default::default(),
        })
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for Error {
    fn meta(&self) -> &::aws_smithy_types::error::metadata::ErrorMetadata {
        match self {
            Self::AccessDeniedException(inner) => inner.meta(),
            Self::ExpiredTokenException(inner) => inner.meta(),
            Self::InternalServerException(inner) => inner.meta(),
            Self::InvalidParameterException(inner) => inner.meta(),
            Self::InvalidRequestException(inner) => inner.meta(),
            Self::InvalidTokenException(inner) => inner.meta(),
            Self::ResourceNotFoundException(inner) => inner.meta(),
            Self::ServiceUnavailableException(inner) => inner.meta(),
            Self::ThrottlingException(inner) => inner.meta(),
            Self::Unhandled(inner) => &inner.meta,
        }
    }
}
impl<R> From<::aws_smithy_runtime_api::client::result::SdkError<crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError, R>,
    ) -> Self {
        match err {
            ::aws_smithy_runtime_api::client::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::sealed_unhandled::Unhandled {
                meta: ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                source: err.into(),
            }),
        }
    }
}
impl From<crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError> for Error {
    fn from(err: crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError) -> Self {
        match err {
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::AccessDeniedException(inner) => {
                Error::AccessDeniedException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::ExpiredTokenException(inner) => {
                Error::ExpiredTokenException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::InternalServerException(inner) => {
                Error::InternalServerException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::InvalidParameterException(inner) => {
                Error::InvalidParameterException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::InvalidRequestException(inner) => {
                Error::InvalidRequestException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::InvalidTokenException(inner) => {
                Error::InvalidTokenException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::ResourceNotFoundException(inner) => {
                Error::ResourceNotFoundException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::ServiceUnavailableException(inner) => {
                Error::ServiceUnavailableException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::operation::assume_role_for_pod_identity::AssumeRoleForPodIdentityError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl ::std::error::Error for Error {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Error::AccessDeniedException(inner) => inner.source(),
            Error::ExpiredTokenException(inner) => inner.source(),
            Error::InternalServerException(inner) => inner.source(),
            Error::InvalidParameterException(inner) => inner.source(),
            Error::InvalidRequestException(inner) => inner.source(),
            Error::InvalidTokenException(inner) => inner.source(),
            Error::ResourceNotFoundException(inner) => inner.source(),
            Error::ServiceUnavailableException(inner) => inner.source(),
            Error::ThrottlingException(inner) => inner.source(),
            Error::Unhandled(inner) => ::std::option::Option::Some(&*inner.source),
        }
    }
}
impl ::aws_types::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessDeniedException(e) => e.request_id(),
            Self::ExpiredTokenException(e) => e.request_id(),
            Self::InternalServerException(e) => e.request_id(),
            Self::InvalidParameterException(e) => e.request_id(),
            Self::InvalidRequestException(e) => e.request_id(),
            Self::InvalidTokenException(e) => e.request_id(),
            Self::ResourceNotFoundException(e) => e.request_id(),
            Self::ServiceUnavailableException(e) => e.request_id(),
            Self::ThrottlingException(e) => e.request_id(),
            Self::Unhandled(e) => e.meta.request_id(),
        }
    }
}
