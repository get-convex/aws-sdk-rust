// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The stop CIS message progress.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct StopCisMessageProgress {
    /// <p>The progress' total checks.</p>
    pub total_checks: i32,
    /// <p>The progress' successful checks.</p>
    pub successful_checks: i32,
    /// <p>The progress' failed checks.</p>
    pub failed_checks: i32,
    /// <p>The progress' not evaluated checks.</p>
    pub not_evaluated_checks: i32,
    /// <p>The progress' unknown checks.</p>
    pub unknown_checks: i32,
    /// <p>The progress' not applicable checks.</p>
    pub not_applicable_checks: i32,
    /// <p>The progress' informational checks.</p>
    pub informational_checks: i32,
    /// <p>The progress' error checks.</p>
    pub error_checks: i32,
}
impl StopCisMessageProgress {
    /// <p>The progress' total checks.</p>
    pub fn total_checks(&self) -> i32 {
        self.total_checks
    }
    /// <p>The progress' successful checks.</p>
    pub fn successful_checks(&self) -> i32 {
        self.successful_checks
    }
    /// <p>The progress' failed checks.</p>
    pub fn failed_checks(&self) -> i32 {
        self.failed_checks
    }
    /// <p>The progress' not evaluated checks.</p>
    pub fn not_evaluated_checks(&self) -> i32 {
        self.not_evaluated_checks
    }
    /// <p>The progress' unknown checks.</p>
    pub fn unknown_checks(&self) -> i32 {
        self.unknown_checks
    }
    /// <p>The progress' not applicable checks.</p>
    pub fn not_applicable_checks(&self) -> i32 {
        self.not_applicable_checks
    }
    /// <p>The progress' informational checks.</p>
    pub fn informational_checks(&self) -> i32 {
        self.informational_checks
    }
    /// <p>The progress' error checks.</p>
    pub fn error_checks(&self) -> i32 {
        self.error_checks
    }
}
impl StopCisMessageProgress {
    /// Creates a new builder-style object to manufacture [`StopCisMessageProgress`](crate::types::StopCisMessageProgress).
    pub fn builder() -> crate::types::builders::StopCisMessageProgressBuilder {
        crate::types::builders::StopCisMessageProgressBuilder::default()
    }
}

/// A builder for [`StopCisMessageProgress`](crate::types::StopCisMessageProgress).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct StopCisMessageProgressBuilder {
    pub(crate) total_checks: ::std::option::Option<i32>,
    pub(crate) successful_checks: ::std::option::Option<i32>,
    pub(crate) failed_checks: ::std::option::Option<i32>,
    pub(crate) not_evaluated_checks: ::std::option::Option<i32>,
    pub(crate) unknown_checks: ::std::option::Option<i32>,
    pub(crate) not_applicable_checks: ::std::option::Option<i32>,
    pub(crate) informational_checks: ::std::option::Option<i32>,
    pub(crate) error_checks: ::std::option::Option<i32>,
}
impl StopCisMessageProgressBuilder {
    /// <p>The progress' total checks.</p>
    pub fn total_checks(mut self, input: i32) -> Self {
        self.total_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' total checks.</p>
    pub fn set_total_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_checks = input;
        self
    }
    /// <p>The progress' total checks.</p>
    pub fn get_total_checks(&self) -> &::std::option::Option<i32> {
        &self.total_checks
    }
    /// <p>The progress' successful checks.</p>
    pub fn successful_checks(mut self, input: i32) -> Self {
        self.successful_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' successful checks.</p>
    pub fn set_successful_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.successful_checks = input;
        self
    }
    /// <p>The progress' successful checks.</p>
    pub fn get_successful_checks(&self) -> &::std::option::Option<i32> {
        &self.successful_checks
    }
    /// <p>The progress' failed checks.</p>
    pub fn failed_checks(mut self, input: i32) -> Self {
        self.failed_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' failed checks.</p>
    pub fn set_failed_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.failed_checks = input;
        self
    }
    /// <p>The progress' failed checks.</p>
    pub fn get_failed_checks(&self) -> &::std::option::Option<i32> {
        &self.failed_checks
    }
    /// <p>The progress' not evaluated checks.</p>
    pub fn not_evaluated_checks(mut self, input: i32) -> Self {
        self.not_evaluated_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' not evaluated checks.</p>
    pub fn set_not_evaluated_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.not_evaluated_checks = input;
        self
    }
    /// <p>The progress' not evaluated checks.</p>
    pub fn get_not_evaluated_checks(&self) -> &::std::option::Option<i32> {
        &self.not_evaluated_checks
    }
    /// <p>The progress' unknown checks.</p>
    pub fn unknown_checks(mut self, input: i32) -> Self {
        self.unknown_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' unknown checks.</p>
    pub fn set_unknown_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.unknown_checks = input;
        self
    }
    /// <p>The progress' unknown checks.</p>
    pub fn get_unknown_checks(&self) -> &::std::option::Option<i32> {
        &self.unknown_checks
    }
    /// <p>The progress' not applicable checks.</p>
    pub fn not_applicable_checks(mut self, input: i32) -> Self {
        self.not_applicable_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' not applicable checks.</p>
    pub fn set_not_applicable_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.not_applicable_checks = input;
        self
    }
    /// <p>The progress' not applicable checks.</p>
    pub fn get_not_applicable_checks(&self) -> &::std::option::Option<i32> {
        &self.not_applicable_checks
    }
    /// <p>The progress' informational checks.</p>
    pub fn informational_checks(mut self, input: i32) -> Self {
        self.informational_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' informational checks.</p>
    pub fn set_informational_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.informational_checks = input;
        self
    }
    /// <p>The progress' informational checks.</p>
    pub fn get_informational_checks(&self) -> &::std::option::Option<i32> {
        &self.informational_checks
    }
    /// <p>The progress' error checks.</p>
    pub fn error_checks(mut self, input: i32) -> Self {
        self.error_checks = ::std::option::Option::Some(input);
        self
    }
    /// <p>The progress' error checks.</p>
    pub fn set_error_checks(mut self, input: ::std::option::Option<i32>) -> Self {
        self.error_checks = input;
        self
    }
    /// <p>The progress' error checks.</p>
    pub fn get_error_checks(&self) -> &::std::option::Option<i32> {
        &self.error_checks
    }
    /// Consumes the builder and constructs a [`StopCisMessageProgress`](crate::types::StopCisMessageProgress).
    pub fn build(self) -> crate::types::StopCisMessageProgress {
        crate::types::StopCisMessageProgress {
            total_checks: self.total_checks.unwrap_or_default(),
            successful_checks: self.successful_checks.unwrap_or_default(),
            failed_checks: self.failed_checks.unwrap_or_default(),
            not_evaluated_checks: self.not_evaluated_checks.unwrap_or_default(),
            unknown_checks: self.unknown_checks.unwrap_or_default(),
            not_applicable_checks: self.not_applicable_checks.unwrap_or_default(),
            informational_checks: self.informational_checks.unwrap_or_default(),
            error_checks: self.error_checks.unwrap_or_default(),
        }
    }
}
